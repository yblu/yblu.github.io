<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[luyunbo's Blog]]></title>
  <link href="http://yblu.github.io/atom.xml" rel="self"/>
  <link href="http://yblu.github.io/"/>
  <updated>2016-03-15T12:03:00+08:00</updated>
  <id>http://yblu.github.io/</id>
  <author>
    <name><![CDATA[Lu Yunbo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[2015年总结]]></title>
    <link href="http://yblu.github.io/blog/2016/01/02/2015-Summary/"/>
    <updated>2016-01-02T00:00:00+08:00</updated>
    <id>http://yblu.github.io/blog/2016/01/02/2015-Summary</id>
    <content type="html"><![CDATA[<p> 2015年，总的来说写码搬砖的一年，
 本来想着试图总结下一年的生活，企图想得到点思想的结晶。但是下笔之后，发现思维浅薄，文笔愚钝。平时还是做的太少，体验太浅，思考太浅。
 想来想去碎碎念下一年的流水，其中浅薄自知，不敢妄图得出人生大论。
 2015年1月7日，开始进入狼厂实习搬砖，从伪科研伪学术转向了写码搬砖，感觉生活一些更真实了一些。
 当然这件事也是坑了带我的师兄，他人很nice，本来会成为科研路上的带路人，不过时事无常，心之所向，再次表示惭愧和感激。
 进入狼厂，本以为会有坊间传闻的互联网的敏捷和高压，但其实作为实习生还是很轻松的，虽然会接触到很多不同的不懂的东西，但是感觉上手起来还是很快的，感觉很快适应，但也迷茫，感觉实际的情况和原来的想象的不太一样。
 现在想来还是too young too naive，你以为学会了hello world，就可以改变世界。
 现在的认知是，漫漫码农路，而今开始从头越，但也不妄自菲薄。</p>

<p> 2015年春节过年回来已经，已经是二月底了，忽悠一下，就了到四月份，去爬了趟黄山。
 那天白天风和日丽，到了山顶的时候，风云突变，起雾，下雨雪，晚上山顶路面都结冰了，本来以为第二天不会有日出的，抱着撞大运的心情四点多起来看，没想到天晴了，有机会看日出，赶紧赶去丹霞峰，运气不错，卡到了一个不错观景位置。
 天都峰的险峻，排云亭的云海仙境，黄山日出的美，嗯，迎客松的人多，哈哈。都领略到。
 “五岳归来不看山，黄山归来不看岳”，只能说确实不枉此行。
 审美往往能在对比中提高，看过了更美的山河，才能会不如它的不过如此。登高望远，征服了更高的山，才能俯瞰众山下。体验了更好的东西，也才会去追求更好。
 想到此，“多读书”，“遇贵人”等等似乎也蕴含着类似的道理吧，遇到更好的，自己也有机会变得更好吧。
 另外黄山一行，损到了膝盖，应该是当年大一被车撞了留下的隐疾。整个黄山之行，还是被某人秒了。靠谱能力还是要努力提高啊。</p>

<p> 黄山回来之后，继续日常，去狼厂搬砖，然后到了七月份，开题答辩，水水的走个过场。
 七八月份，开始刷题，为找工作做准备。感觉和我同一届的同学总能遇到一些“好事”。高中课改第一届的是我们，保研的政策的突变，2015年校招遇到了“互联网寒冬”。
 阿里来去匆匆，拥抱变化。阿里三战三败，看来还是和阿里无缘，内推java的，被面了数据挖掘。。。只怪自己学艺不精。
 鹅厂，也被面试官秒了，一道二分查找白板编程就把我秒了，事后也只能用编程珠玑上的统计来安慰自己了，号称只有10%的人能完全写对，念此还是学艺不精。
 狼厂，算是实习，混了个脸熟，留用了。
 猪厂，去杭州打个酱油，捡了个offer回来，只能说猪厂太看得起我。
 点评，还是比较欣赏的公司，慢而精的公司，也给了offer，可惜国庆回来，就和美团合并了，报团自身前途未卜，也就没敢太多去的念想了。
 还零星投了一些小公司，就不赘述了。
 没有北漂的想法，北京的公司都没投。
 FLAGM，想想还是算了，就不找虐了。
 体验下来，技术还是有待提高，希望三年之后不想成为狼厂的混日子。
 另外几点感悟就是，平台很重要，格局视野很重要，贵人很重要。前提都是自己也是有能力的。（此处满满负能量，省略一万字。）
 学校教育是穷人上升最快途径之一，只可惜自己没能把握好这段时光上升，现在就要快离开了，要去职场和社会中受教育了。</p>

<p> 2015年最后两个月，也是比较忙的一段时间，接手了同事的项目，到了另外一个团队干活。这也是实习一年下来学东西速率最高的一段时间吧，工作相对饱和，也有一定压力。
 对程序员的工作的有了一些新的认识。
 技多不压身，多一门手艺多一条出路，一专多能吧，就像很多人总结的T型人才。
 靠谱很重要。任何原因的不靠谱，都会让别人有换掉你的想法，而不是会期待你靠谱起来。
 人与动物的最大区别是会使用工具。这句话暂不论科学与否，但从某种程度上说明了，人会使用工具是很重要的，生产效率的提高，需要选择合适的工具很重要，熟练工具的使用。
 另外还要学会个性化自定工具，比如想每天第一时间查看汇总系统情况，如果系统没提供可视化工具，可以自己简单快速造一个，一些常用的打包流程，可以自己封装一些工具。
 总之，想办法优化自己的生产效率，让自己的生产生活更愉快些，造轮子也好，使用轮子也好，make things better，make right things happen。
 技术思考的深入性，要用全面的事实说话，不能想当然，瞎说死得快。
 工作的主动性，都思考一步为什么，怎么做。
 要不断提高自我修养，编程规范要自我约束，留坑死全家啊，用狼厂的话就是“简单可依赖”吧。
 技术提高不是目的，要的还是如何变现。技术不分贵贱，变现是王道，改变世界最牛逼。php是世界上最好的语言，哈哈。。。</p>

<p> 碎碎念至此，流水已完。
 2015年还是做的太少，体验太浅。没什么好的，也没什么不好的。
 2016年已经开始，做好自己的事，朝某个目标慢慢前进吧，不断努力去遇见更好的风景。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Protocol Buffer 语法指南]]></title>
    <link href="http://yblu.github.io/blog/2015/06/03/PB-LanguageGuide/"/>
    <updated>2015-06-03T00:00:00+08:00</updated>
    <id>http://yblu.github.io/blog/2015/06/03/PB-LanguageGuide</id>
    <content type="html"><![CDATA[<h2>定义一个消息类型</h2>

<p>先来看一个非常简单的例子。假设你想定义一个“搜索请求”的消息格式，每一个请求含有一个查询字符串、你感兴趣的查询结果所在的页数，以及每一页多少条查询结果。可以采用如下的方式来定义消息类型的.proto文件了：</p>

<pre><code>message SearchRequest {
  required string query = 1;
  optional int32 page_number = 2;
  optional int32 result_per_page = 3;
}
</code></pre>

<p>SearchRequest消息格式有3个字段，在消息中承载的数据分别对应于每一个字段。其中每个字段都有一个名字和一种类型。</p>

<h3>指定字段类型</h3>

<p>在上面的例子中，所有字段都是标量类型：两个整型（page_number和result_per_page），一个string类型（query）。当然，你也可以为字段指定其他的合成类型，包括枚举（enumerations）或其他消息类型。</p>

<h3>分配标识号</h3>

<p>正如上述文件格式，在消息定义中，每个字段都有唯一的一个数字标识符。这些标识符是用来在消息的二进制格式中识别各个字段的，一旦开始使用就不能够再改变。注：[1,15]之内的标识号在编码的时候会占用一个字节。[16,2047]之内的标识号则占用2个字节。所以应该为那些频繁出现的消息元素保留 [1,15]之内的标识号。切记：要为将来有可能添加的、频繁出现的标识号预留一些标识号。</p>

<p>最小的标识号可以从1开始，最大到2<sup>29</sup> - 1, or 536,870,911。不可以使用其中的[19000－19999]的标识号， Protobuf协议实现中对这些进行了预留。如果非要在.proto文件中使用这些预留标识号，编译时就会报警。</p>

<h3>指定字段规则</h3>

<p>所指定的消息字段修饰符必须是如下之一：
* required：一个格式良好的消息一定要含有1个这种字段。表示该值是必须要设置的；
* optional：消息格式中该字段可以有0个或1个值（不超过1个）。
* repeated：在一个格式良好的消息中，这种字段可以重复任意多次（包括0次）。重复的值的顺序会被保留。表示该值可以重复，相当于java中的List。</p>

<p>由于一些历史原因，基本数值类型的repeated的字段并没有被尽可能地高效编码。在新的代码中，用户应该使用特殊选项[packed=true]来保证更高效的编码。如：</p>

<pre><code>repeated int32 samples = 4 [packed=true];
</code></pre>

<p>required是永久性的：在将一个字段标识为required的时候，应该特别小心。如果在某些情况下不想写入或者发送一个required的字段，将原始该字段修饰符更改为optional可能会遇到问题——旧版本的使用者会认为不含该字段的消息是不完整的，从而可能会无目的的拒绝解析。在这种情况下，你应该考虑编写特别针对于应用程序的、自定义的消息校验函数。Google的一些工程师得出了一个结论：使用required弊多于利；他们更 愿意使用optional和repeated而不是required。当然，这个观点并不具有普遍性。</p>

<h3>添加更多消息类型</h3>

<p>在一个.proto文件中可以定义多个消息类型。在定义多个相关的消息的时候，这一点特别有用——例如，如果想定义与SearchResponse消息类型对应的回复消息格式的话，你可以将它添加到相同的.proto文件中，如：</p>

<pre><code>message SearchRequest {
  required string query = 1;
  optional int32 page_number = 2;
  optional int32 result_per_page = 3;
}

message SearchResponse {
 ...
}
</code></pre>

<h3>添加注释</h3>

<p>向.proto文件添加注释，可以使用C/C++/java风格的双斜杠（//） 语法格式，如：</p>

<pre><code>message SearchRequest {
  required string query = 1;
  optional int32 page_number = 2;// Which page number do we want?
  optional int32 result_per_page = 3;// Number of results to return per page.
}
</code></pre>

<h3>从.proto文件生成了什么？</h3>

<p>当用protocolbuffer编译器来运行.proto文件时，编译器将生成所选择语言的代码，这些代码可以操作在.proto文件中定义的消息类型，包括获取、设置字段值，将消息序列化到一个输出流中，以及从一个输入流中解析消息。</p>

<ul>
<li>对C++来说，编译器会为每个.proto文件生成一个.h文件和一个.cc文件，.proto文件中的每一个消息有一个对应的类。</li>
<li>对Java来说，编译器为每一个消息类型生成了一个.java文件，以及一个特殊的Builder类（该类是用来创建消息类接口的）。</li>
<li>对Python来说，有点不太一样——Python编译器为.proto文件中的每个消息类型生成一个含有静态描述符的模块，，该模块与一个元类（metaclass）在运行时（runtime）被用来创建所需的Python数据访问类。
你可以从如下的文档链接中获取每种语言更多API。<a href="http://code.google.com/intl/zh-CN/apis/protocolbuffers/docs/reference/overview.htm">http://code.google.com/intl/zh-CN/apis/protocolbuffers/docs/reference/overview.htm</a></li>
</ul>


<h2>标量数值类型</h2>

<p>一个标量消息字段可以含有一个如下的类型——该表格展示了定义于.proto文件中的类型，以及与之对应的、在自动生成的访问类中定义的类型：</p>

<table><tbody><tr><td><p>.proto类型</p></td><td><p>Java 类型</p></td><td><p>C++类型</p></td><td><p>备注</p></td></tr><tr><td><p>double</p></td><td><p>double</p></td><td><p>double</p></td><td><p>&nbsp;</p></td></tr><tr><td><p>float</p></td><td><p>float</p></td><td><p>float</p></td><td><p>&nbsp;</p></td></tr><tr><td><p>int32</p></td><td><p>int</p></td><td><p>int32</p></td><td><p>使用可变长编码方式。编码负数时不够高效——如果你的字段可能含有负数，那么请使用sint32。</p></td></tr><tr><td><p>int64</p></td><td><p>long</p></td><td><p>int64</p></td><td><p>使用可变长编码方式。编码负数时不够高效——如果你的字段可能含有负数，那么请使用sint64。</p></td></tr><tr><td><p>uint32</p></td><td><p>int[1]</p></td><td><p>uint32</p></td><td><p>Uses variable-length encoding.</p></td></tr><tr><td><p>uint64</p></td><td>long[1]</td><td>uint64</td><td>Uses variable-length encoding.</td></tr><tr><td><p>sint32</p></td><td><p>int</p></td><td><p>int32</p></td><td><p>使用可变长编码方式。有符号的整型值。编码时比通常的int32高效。</p></td></tr><tr><td><p>sint64</p></td><td><p>long</p></td><td><p>int64</p></td><td><p>使用可变长编码方式。有符号的整型值。编码时比通常的int64高效。</p></td></tr><tr><td><p>fixed32</p></td><td><p>int[1]</p></td><td><p>uint32</p></td><td><p>总是4个字节。如果数值总是比总是比228大的话，这个类型会比uint32高效。</p></td></tr><tr><td><p>fixed64</p></td><td><p>long[1]</p></td><td><p>uint64</p></td><td><p>总是8个字节。如果数值总是比总是比256大的话，这个类型会比uint64高效。</p></td></tr><tr><td><p>sfixed32</p></td><td><p>int</p></td><td><p>int32</p></td><td><p>总是4个字节。</p></td></tr><tr><td><p>sfixed64</p></td><td><p>long</p></td><td><p>int64</p></td><td><p>总是8个字节。</p></td></tr><tr><td><p>bool</p></td><td><p>boolean</p></td><td><p>bool</p></td><td><p>&nbsp;</p></td></tr><tr><td><p>string</p></td><td><p>String</p></td><td><p>string</p></td><td><p>一个字符串必须是UTF-8编码或者7-bit ASCII编码的文本。</p></td></tr><tr><td><p>bytes</p></td><td><p>ByteString</p></td><td><p>string</p></td><td><p>可能包含任意顺序的字节数据。</p></td></tr></tbody></table>


<p>你可以在文章<a href="http://code.google.com/apis/protocolbuffers/docs/encoding.html">http://code.google.com/apis/protocolbuffers/docs/encoding.html</a> 中，找到更多“序列化消息时各种类型如何编码”的信息。</p>

<h2>Optional的字段和默认值</h2>

<p>如上所述，消息描述中的一个元素可以被标记为“可选的”（optional）。一个格式良好的消息可以包含0个或一个optional的元素。当解 析消息时，如果它不包含optional的元素值，那么解析出来的对象中的对应字段就被置为默认值。默认值可以在消息描述文件中指定。例如，要为 SearchRequest消息的result_per_page字段指定默认值10，在定义消息格式时如下所示：</p>

<pre><code>optional int32 result_per_page = 3 [default = 10];
</code></pre>

<p>如果没有为optional的元素指定默认值，就会使用与特定类型相关的默认值：对string来说，默认值是空字符串。对bool来说，默认值是false。对数值类型来说，默认值是0。对枚举来说，默认值是枚举类型定义中的第一个值。</p>

<h2>枚举</h2>

<p>当需要定义一个消息类型的时候，可能想为一个字段指定某“预定义值序列”中的一个值。例如，假设要为每一个SearchRequest消息添加一个 corpus字段，而corpus的值可能是UNIVERSAL，WEB，IMAGES，LOCAL，NEWS，PRODUCTS或VIDEO中的一个。 其实可以很容易地实现这一点：通过向消息定义中添加一个枚举（enum）就可以了。一个enum类型的字段只能用指定的常量集中的一个值作为其值（如果尝 试指定不同的值，解析器就会把它当作一个未知的字段来对待）。在下面的例子中，在消息格式中添加了一个叫做Corpus的枚举类型——它含有所有可能的值 ——以及一个类型为Corpus的字段：</p>

<pre><code>message SearchRequest {
  required string query = 1;
  optional int32 page_number = 2;
  optional int32 result_per_page = 3 [default = 10];
  enum Corpus {
    UNIVERSAL = 0;
    WEB = 1;
    IMAGES = 2;
    LOCAL = 3;
    NEWS = 4;
    PRODUCTS = 5;
    VIDEO = 6;
  }
  optional Corpus corpus = 4 [default = UNIVERSAL];
}
</code></pre>

<p>你可以为枚举常量定义别名。 需要设置allow_alias option 为 true, 否则 protocol编译器会产生错误信息。</p>

<pre><code>enum EnumAllowingAlias {
  option allow_alias = true;
  UNKNOWN = 0;
  STARTED = 1;
  RUNNING = 1;
}
enum EnumNotAllowingAlias {
  UNKNOWN = 0;
  STARTED = 1;
  // RUNNING = 1;  // Uncommenting this line will cause a compile error inside Google and a warning message outside.
}
</code></pre>

<p>枚举常量必须在32位整型值的范围内。因为enum值是使用可变编码方式的，对负数不够高效，因此不推荐在enum中使用负数。如上例所示，可以在 一个消息定义的内部或外部定义枚举——这些枚举可以在.proto文件中的任何消息定义里重用。当然也可以在一个消息中声明一个枚举类型，而在另一个不同 的消息中使用它——采用MessageType.EnumType的语法格式。</p>

<p>当对一个使用了枚举的.proto文件运行protocol buffer编译器的时候，生成的代码中将有一个对应的enum（对Java或C++来说），或者一个特殊的EnumDescriptor类（对 Python来说），它被用来在运行时生成的类中创建一系列的整型值符号常量（symbolic constants）。</p>

<p>关于如何在你的应用程序的消息中使用枚举的更多信息，请查看所选择的语言<a href="http://code.google.com/intl/zh-CN/apis/protocolbuffers/docs/reference/overview.html%E3%80%82">http://code.google.com/intl/zh-CN/apis/protocolbuffers/docs/reference/overview.html%E3%80%82</a></p>

<h2>使用其他消息类型</h2>

<p>你可以将其他消息类型用作字段类型。例如，假设在每一个SearchResponse消息中包含Result消息，此时可以在相同的.proto文件中定义一个Result消息类型，然后在SearchResponse消息中指定一个Result类型的字段，如：</p>

<pre><code>message SearchResponse {
  repeated Result result = 1;
}

message Result {
  required string url = 1;
  optional string title = 2;
  repeated string snippets = 3;
}
</code></pre>

<h3>导入定义</h3>

<p>在上面的例子中，Result消息类型与SearchResponse是定义在同一文件中的。如果想要使用的消息类型已经在其他.proto文件中已经定义过了呢？
你可以通过导入（importing）其他.proto文件中的定义来使用它们。要导入其他.proto文件的定义，你需要在你的文件中添加一个导入声明，如：</p>

<pre><code>import "myproject/other_protos.proto";
</code></pre>

<p>默认情况下你只能使用直接导入的.proto文件中的定义. 然而， 有时候你需要移动一个.proto文件到一个新的位置， 可以不直接移动.proto文件， 只需放入一个dummy .proto 文件在老的位置， 然后使用import转向新的位置:</p>

<pre><code>// new.proto
// All definitions are moved here
</code></pre>

<p>.</p>

<pre><code>// old.proto
// This is the proto that all clients are importing.
import public "new.proto";
import "other.proto";
</code></pre>

<p>.</p>

<pre><code>// client.proto
import "old.proto";
// You use definitions from old.proto and new.proto, but not other.proto
</code></pre>

<p>protocol编译器就会在一系列目录中查找需要被导入的文件，这些目录通过protocol编译器的命令行参数-I/–import_path指定。如果不提供参数，编译器就在其调用目录下查找。</p>

<h2>嵌套类型</h2>

<p>你可以在其他消息类型中定义、使用消息类型，在下面的例子中，Result消息就定义在SearchResponse消息内，如：</p>

<pre><code>message SearchResponse {
  message Result {
    required string url = 1;
    optional string title = 2;
    repeated string snippets = 3;
  }
  repeated Result result = 1;
}
</code></pre>

<p>如果你想在它的父消息类型的外部重用这个消息类型，你需要以Parent.Type的形式使用它，如：</p>

<pre><code>message SomeOtherMessage {
  optional SearchResponse.Result result = 1;
}
</code></pre>

<p>当然，你也可以将消息嵌套任意多层，如：</p>

<pre><code>message Outer {                  // Level 0
  message MiddleAA {  // Level 1
    message Inner {   // Level 2
      required int64 ival = 1;
      optional bool  booly = 2;
    }
  }
  message MiddleBB {  // Level 1
    message Inner {   // Level 2
      required int32 ival = 1;
      optional bool  booly = 2;
    }
  }
}
</code></pre>

<h3>组</h3>

<p><strong>注：该特性已被弃用，在创建新的消息类型的时候，不应该再使用它——可以使用嵌套消息类型来代替它。</strong>
“组”是指在消息定义中嵌套信息的另一种方法。比如，在SearchResponse中包含若干Result的另一种方法是 ：</p>

<pre><code>message SearchResponse {
  repeated group Result = 1 {
    required string url = 2;
    optional string title = 3;
    repeated string snippets = 4;
  }
}
</code></pre>

<p>一个“组”只是简单地将一个嵌套消息类型和一个字段捆绑到一个单独的声明中。在代码中，可以把它看成是含有一个Result类型、名叫result的字段的消息（后面的名字被转换成了小写，所以它不会与前面的冲突）。</p>

<p>因此，除了数据传输格式不同之外，这个例子与上面的SearchResponse例子是完全等价的。</p>

<h2>更新一个消息类型</h2>

<p>如果一个已有的消息格式已无法满足新的需求——如，要在消息中添加一个额外的字段——但是同时旧版本写的代码仍然可用。不用担心！更新消息而不破坏已有代码是非常简单的。在更新时只要记住以下的规则即可。</p>

<ul>
<li>不要更改任何已有的字段的数值标识。</li>
<li>所添加的任何字段都必须是optional或repeated的。这就意味着任何使用“旧”的消息格式的代码序列化的消息可以被新的代码所解析，因为它们 不会丢掉任何required的元素。应该为这些元素设置合理的默认值，这样新的代码就能够正确地与老代码生成的消息交互了。类似地，新的代码创建的消息 也能被老的代码解析：老的二进制程序在解析的时候只是简单地将新字段忽略。然而，未知的字段是没有被抛弃的。此后，如果消息被序列化，未知的字段会随之一 起被序列化——所以，如果消息传到了新代码那里，则新的字段仍然可用。注意：对Python来说，对未知字段的保留策略是无效的。</li>
<li>非required的字段可以移除——只要它们的标识号在新的消息类型中不再使用（更好的做法可能是重命名那个字段，例如在字段前添加“OBSOLETE_”前缀，那样的话，使用的.proto文件的用户将来就不会无意中重新使用了那些不该使用的标识号）。</li>
<li>一个非required的字段可以转换为一个扩展，反之亦然——只要它的类型和标识号保持不变。</li>
<li>int32, uint32, int64, uint64,和bool是全部兼容的，这意味着可以将这些类型中的一个转换为另外一个，而不会破坏向前、 向后的兼容性。如果解析出来的数字与对应的类型不相符，那么结果就像在C++中对它进行了强制类型转换一样（例如，如果把一个64位数字当作int32来 读取，那么它就会被截断为32位的数字）。</li>
<li>sint32和sint64是互相兼容的，但是它们与其他整数类型不兼容。</li>
<li>string和bytes是兼容的——只要bytes是有效的UTF-8编码。</li>
<li>嵌套消息与bytes是兼容的——只要bytes包含该消息的一个编码过的版本。</li>
<li>fixed32与sfixed32是兼容的，fixed64与sfixed64是兼容的。</li>
</ul>


<h2>扩展</h2>

<p>通过扩展，可以将一个范围内的字段标识号声明为可被第三方扩展所用。然后，其他人就可以在他们自己的.proto文件中为该消息类型声明新的字段，而不必去编辑原始文件了。看个具体例子：</p>

<pre><code>message Foo {
  // ...
  extensions 100 to 199;
}
</code></pre>

<p>这个例子表明：在消息Foo中，范围[100,199]之内的字段标识号被保留为扩展用。现在，其他人就可以在他们自己的.proto文件中添加新字段到Foo里了，但是添加的字段标识号要在指定的范围内——例如：</p>

<pre><code>extend Foo {
  optional int32 bar = 126;
}
</code></pre>

<p>这个例子表明：消息Foo现在有一个名为bar的optional int32字段。</p>

<p>当用户的Foo消息被编码的时候，数据的传输格式与用户在Foo里定义新字段的效果是完全一样的。
然而，要在程序代码中访问扩展字段的方法与访问普通的字段稍有不同——生成的数据访问代码为扩展准备了特殊的访问函数来访问它。例如，下面是如何在C++中设置bar的值：</p>

<pre><code>Foo foo;
foo.SetExtension(bar, 15);
</code></pre>

<p>类似地，Foo类也定义了模板函数 HasExtension()，ClearExtension()，GetExtension()，MutableExtension()，以及 AddExtension()。这些函数的语义都与对应的普通字段的访问函数相符。要查看更多使用扩展的信息，请参考相应语言的代码生成指南。注：扩展可 以是任何字段类型，包括消息类型。</p>

<h3>嵌套的扩展</h3>

<p>可以在另一个类型的范围内声明扩展，如：</p>

<pre><code>message Baz {
  extend Foo {
    optional int32 bar = 126;
  }
  ...
}
</code></pre>

<p>在此例中，访问此扩展的C++代码如下：</p>

<pre><code>Foo foo;
foo.SetExtension(Baz::bar, 15);
</code></pre>

<p>n other words, the only effect is that bar is defined within the scope of Baz.</p>

<blockquote><p>This is a common source of confusion: Declaring an extend block nested inside a message type does not imply any relationship between the outer type and the extended type. In particular, the above example does not mean that Baz is any sort of subclass of Foo. All it means is that the symbol bar is declared inside the scope of Baz; it&rsquo;s simply a static member.</p></blockquote>

<p>一个通常的设计模式就是：在扩展的字段类型的范围内定义该扩展——例如，下面是一个Foo的扩展（该扩展是Baz类型的），其中，扩展被定义为了Baz的一部分：</p>

<pre><code>message Baz {
  extend Foo {
    optional Baz foo_ext = 127;
  }
  ...
}
</code></pre>

<p>然而，并没有强制要求一个消息类型的扩展一定要定义在那个消息中。也可以这样做：</p>

<pre><code>message Baz {
  ...
}

// This can even be in a different file.
extend Foo {
  optional Baz foo_baz_ext = 127;
}
</code></pre>

<p>事实上，这种语法格式更能防止引起混淆。正如上面所提到的，嵌套的语法通常被错误地认为有子类化的关系——尤其是对那些还不熟悉扩展的用户来说。</p>

<h3>选择可扩展的标量符号</h3>

<p>在同一个消息类型中一定要确保两个用户不会扩展新增相同的标识号，否则可能会导致数据的不一致。可以通过为新项目定义一个可扩展标识号规则来防止该情况的发生。</p>

<p>如果标识号需要很大的数量时，可以将该可扩展标符号的范围扩大至max，其中max是2<sup>29</sup> - 1, 或536,870,911。如下所示：</p>

<pre><code>message Foo {
  extensions 1000 to max;
}
</code></pre>

<p>max 是 2<sup>29</sup> - 1, 或者 536,870,911.</p>

<p>通常情况下在选择标符号时，标识号产生的规则中应该避开[19000－19999]之间的数字，因为这些已经被Protocol Buffers实现中预留了。</p>

<h2>Oneof</h2>

<p>如果你的消息中有很多可选字段， 并且同时至多一个字段会被设置， 你可以加强这个行为，使用oneof特性节省内存.</p>

<p>Oneof字段就像可选字段， 除了它们会共享内存， 至多一个字段会被设置。 设置其中一个字段会清除其它oneof字段。 你可以使用case()或者WhichOneof() 方法检查哪个oneof字段被设置， 看你使用什么语言了.</p>

<h3>使用 oneof</h3>

<p>为了在.proto定义Oneof字段， 你需要在名字前面加上oneof关键字, 比如下面例子的test_oneof:</p>

<pre><code>message SampleMessage {
  oneof test_oneof {
     string name = 4;
     SubMessage sub_message = 9;
  }
}
</code></pre>

<p>然后你可以增加oneof字段到 oneof 定义中. 你可以增加任意类型的字段, 但是不能使用 required, optional, repeated 关键字.</p>

<p>在产生的代码中, oneof字段拥有同样的 getters 和setters， 就像正常的可选字段一样. 也有一个特殊的方法来检查到底那个字段被设置. 你可以在相应的语言API中找到oneof API介绍.</p>

<h3>Oneof 的特性</h3>

<ul>
<li><p>设置oneof会自动清楚其它oneof字段的值. 所以设置多次后，只有最后一次设置的字段有值.</p>

<pre><code>  SampleMessage message;
  message.set_name("name");
  CHECK(message.has_name());
  message.mutable_sub_message();   // Will clear name field.
  CHECK(!message.has_name());
</code></pre></li>
<li><p>If the parser encounters multiple members of the same oneof on the wire, only the last member seen is used in the parsed message.</p></li>
<li>oneof不支持扩展.</li>
<li>oneof不能 repeated.</li>
<li>反射API对oneof 字段有效.</li>
<li><p>如果使用C++,需确保代码不会导致内存泄漏. 下面的代码会崩溃， 因为sub_message 已经通过set_name()删除了.</p>

<pre><code>  SampleMessage message;
  SubMessage* sub_message = message.mutable_sub_message();
  message.set_name("name");      // Will delete sub_message
  sub_message-&gt;set_...            // Crashes here
</code></pre></li>
<li><p>Again in C++, if you Swap() two messages with oneofs, each message will end up with the other’s oneof case: in the example below, msg1 will have a sub_message and msg2 will have a name.</p>

<pre><code>  SampleMessage msg1;
  msg1.set_name("name");
  SampleMessage msg2;
  msg2.mutable_sub_message();
  msg1.swap(&amp;msg2);
  CHECK(msg1.has_sub_message());
  CHECK(msg2.has_name());
</code></pre></li>
</ul>


<h3>向后兼容性问题</h3>

<p>当增加或者删除oneof字段时一定要小心. 如果检查oneof的值返回None/NOT_SET, 它意味着oneof字段没有被赋值或者在一个不同的版本中赋值了。 你不会知道是哪种情况。</p>

<p><strong>Tag 重用问题</strong></p>

<ul>
<li><strong>Move optional fields into or out of a oneof:</strong> You may lose some of your information (some fields will be cleared) after the message is serialized and parsed.</li>
<li><strong>Delete a oneof field and add it back:</strong> This may clear your currently set oneof field after the message is serialized and parsed.</li>
<li><strong>Split or merge oneof:</strong> This has similar issues to moving regular optional fields.</li>
</ul>


<h2>包</h2>

<p>当然可以为.proto文件新增一个可选的package声明符，用来防止不同的消息类型有命名冲突。如：</p>

<pre><code>package foo.bar;
message Open { ... }
</code></pre>

<p>在其他的消息格式定义中可以使用包名+消息名的方式来定义域的类型，如：</p>

<pre><code>message Foo {
  ...
  required foo.bar.Open open = 1;
  ...
}
</code></pre>

<p>包的声明符会根据使用语言的不同影响生成的代码。</p>

<ul>
<li>对于C++，产生的类会被包装在C++的命名空间中，如上例中的Open会被封装在 foo::bar空间中；</li>
<li>对于Java，包声明符会变为java的一个包，除非在.proto文件中提供了一个明确有java_package；</li>
<li>对于 Python，这个包声明符是被忽略的，因为Python模块是按照其在文件系统中的位置进行组织的。</li>
</ul>


<h3>包及名称的解析</h3>

<p>Protocol buffer语言中类型名称的解析与C++是一致的：首先从最内部开始查找，依次向外进行，每个包会被看作是其父类包的内部类。当然对于 （foo.bar.Baz）这样以“.”分隔的意味着是从最外围开始的。ProtocolBuffer编译器会解析.proto文件中定义的所有类型名。 对于不同语言的代码生成器会知道如何来指向每个具体的类型，即使它们使用了不同的规则。</p>

<h2>定义服务(Service)</h2>

<p>如果想要将消息类型用在RPC(远程方法调用)系统中，可以在.proto文件中定义一个RPC服务接口，protocol buffer编译器将会根据所选择的不同语言生成服务接口代码及存根。如，想要定义一个RPC服务并具有一个方法，该方法能够接收 SearchRequest并返回一个SearchResponse，此时可以在.proto文件中进行如下定义：</p>

<pre><code>service SearchService {
  rpc Search (SearchRequest) returns (SearchResponse);
}
</code></pre>

<p>protocol编译器将产生一个抽象接口SearchService以及一个相应的存根实现。存根将所有的调用指向RpcChannel，它是一 个抽象接口，必须在RPC系统中对该接口进行实现。如，可以实现RpcChannel以完成序列化消息并通过HTTP方式来发送到一个服务器。换句话说， 产生的存根提供了一个类型安全的接口用来完成基于protocolbuffer的RPC调用，而不是将你限定在一个特定的RPC的实现中。C++中的代码 如下所示：</p>

<pre><code>using google::protobuf;

protobuf::RpcChannel* channel;
protobuf::RpcController* controller;
SearchService* service;
SearchRequest request;
SearchResponse response;

void DoSearch() {
  // You provide classes MyRpcChannel and MyRpcController, which implement
  // the abstract interfaces protobuf::RpcChannel and protobuf::RpcController.
  channel = new MyRpcChannel("somehost.example.com:1234");
  controller = new MyRpcController;

  // The protocol compiler generates the SearchService class based on the
  // definition given above.
  service = new SearchService::Stub(channel);

  // Set up the request.
  request.set_query("protocol buffers");

  // Execute the RPC.
  service-&gt;Search(controller, request, response, protobuf::NewCallback(&amp;Done));
}

void Done() {
  delete service;
  delete channel;
  delete controller;
}
</code></pre>

<p>所有service类都必须实现Service接口，它提供了一种用来调用具体方法的方式，即在编译期不需要知道方法名及它的输入、输出类型。在服务器端，通过服务注册它可以被用来实现一个RPC Server。</p>

<pre><code>using google::protobuf;

class ExampleSearchService : public SearchService {
public:
void Search(protobuf::RpcController* controller,
          const SearchRequest* request,
          SearchResponse* response,
          protobuf::Closure* done) {
    if (request-&gt;query() == "google") {
      response-&gt;add_result()-&gt;set_url("http://www.google.com");
    } else if (request-&gt;query() == "protocol buffers") {
      response-&gt;add_result()-&gt;set_url("http://protobuf.googlecode.com");
    }
    done-&gt;Run();
  }
};

int main() {
  // You provide class MyRpcServer.  It does not have to implement any
  // particular interface; this is just an example.
  MyRpcServer server;

  protobuf::Service* service = new ExampleSearchService;
  server.ExportOnPort(1234, service);
  server.Run();

  delete service;
  return 0;
}
</code></pre>

<p>There are a number of ongoing third-party projects to develop RPC implementations for Protocol Buffers. For a list of links to projects we know about, see the third-party add-ons wiki page.</p>

<h2>选项（Options）</h2>

<p>在定义.proto文件时能够标注一系列的options。Options并不改变整个文件声明的含义，但却能够影响特定环境下处理方式。完整的可用选项可以在google/protobuf/descriptor.proto找到。</p>

<p>一些选项是文件级别的，意味着它可以作用于最外范围，不包含在任何消息内部、enum或服务定义中。一些选项是消息级别的，意味着它可以用在消息定 义的内部。当然有些选项可以作用在域、enum类型、enum值、服务类型及服务方法中。到目前为止，并没有一种有效的选项能作用于所有的类型。</p>

<p>如下就是一些常用的选择：</p>

<ul>
<li><p><code>java_package</code>(file option): 这个选项表明生成java类所在的包。如果在.proto文件中没有明确的声明<code>java_package</code>，就采用默认的包名。当然了，默认方式产生的 java包名并不是最好的方式，按照应用名称倒序方式进行排序的。如果不需要产生java代码，则该选项将不起任何作用。如：</p>

<pre><code>  option java_package = "com.example.foo";
</code></pre></li>
<li><p><code>java_outer_classname</code> (file option): 该选项表明想要生成Java类的名称。如果在.proto文件中没有明确的java_outer_classname定义，生成的class名称将会根据.proto文件的名称采用驼峰式的命名方式进行生成。如（foo_bar.proto生成的java类名为FooBar.java）,如果不生成java代码，则该选项不起任何作用。如：</p>

<pre><code>  option java_outer_classname = "Ponycopter";
</code></pre></li>
<li><p><code>optimize_for</code>(fileoption): 可以被设置为 SPEED, CODE_SIZE,or LITE_RUNTIME。这些值将通过如下的方式影响C++及java代码的生成：</p>

<ul>
<li><code>SPEED</code> (default): protocol buffer编译器将通过在消息类型上执行序列化、语法分析及其他通用的操作。这种代码是最优的。</li>
<li><code>CODE_SIZE</code>: protocol buffer编译器将会产生最少量的类，通过共享或基于反射的代码来实现序列化、语法分析及各种其它操作。采用该方式产生的代码将比SPEED要少得多， 但是操作要相对慢些。当然实现的类及其对外的API与SPEED模式都是一样的。这种方式经常用在一些包含大量的.proto文件而且并不盲目追求速度的 应用中。</li>
<li><p><code>LITE_RUNTIME</code>: protocol buffer编译器依赖于运行时核心类库来生成代码（即采用libprotobuf-lite 替代libprotobuf）。这种核心类库由于忽略了一 些描述符及反射，要比全类库小得多。这种模式经常在移动手机平台应用多一些。编译器采用该模式产生的方法实现与SPEED模式不相上下，产生的类通过实现 MessageLite接口，但它仅仅是Messager接口的一个子集。</p>

<pre><code>  option optimize_for = CODE_SIZE;
</code></pre></li>
</ul>
</li>
<li><p><code>cc_generic_services</code>, <code>java_generic_services</code>, <code>py_generic_services</code> (file options): 在C++、java、python中protocol buffer编译器是否应该基于服务定义产生抽象服务代码。由于历史遗留问题，该值默认是true。但是自2.3.0版本以来，它被认为通过提供代码生成 器插件来对RPC实现更可取，而不是依赖于“抽象”服务。</p>

<pre><code>  // This file relies on plugins to generate service code.
  option cc_generic_services = false;
  option java_generic_services = false;
  option py_generic_services = false;
</code></pre></li>
<li><p><code>message_set_wire_format</code>(message option): 如果该值被设置为true，该消息将使用一种不同的二进制格式来与Google内部的MessageSet的老格式相兼容。对于Google外部的用户来说，该选项将不会被用到。如下所示:</p>

<pre><code>  message Foo {
    option message_set_wire_format = true;
    extensions 4 to max;
  }
</code></pre></li>
<li><p><code>packed</code> (field option): 如果该选项在一个整型基本类型上被设置为真，则采用更紧凑的编码方式。当然使用该值并不会对数值造成任何损失。在2.3.0版本之前，解析器将会忽略那些 非期望的包装值。因此，它不可能在不破坏现有框架的兼容性上而改变压缩格式。在2.3.0之后，这种改变将是安全的，解析器能够接受上述两种格式，但是在 处理protobuf老版本程序时，还是要多留意一下。</p>

<pre><code>  repeated int32 samples = 4 [packed=true];
</code></pre></li>
<li><p><code>deprecated</code> (field option): 如果该选项被设置为true，表明该字段已经被弃用了，在新代码中不建议使用。在多数语言中，这并没有实际的含义。在java中，它将会变成一个 @Deprecated注释。也许在将来，其它基于语言声明的代码在生成时也会如此使用，当使用该字段时，编译器将自动报警。如：</p>

<pre><code>  optional int32 old_field = 6 [deprecated=true];
</code></pre></li>
</ul>


<h3>自定义选项</h3>

<p>ProtocolBuffers允许自定义并使用选项。该功能应该属于一个高级特性，对于大部分人是用不到的。由于options是定在 google/protobuf/descriptor.proto中的，因此你可以在该文件中进行扩展，定义自己的选项。如：</p>

<pre><code>import "google/protobuf/descriptor.proto";

extend google.protobuf.MessageOptions {
  optional string my_option = 51234;
}

message MyMessage {
  option (my_option) = "Hello world!";
}
</code></pre>

<p>在上述代码中，通过对MessageOptions进行扩展定义了一个新的消息级别的选项。当使用该选项时，选项的名称需要使用（）包裹起来，以表明它是一个扩展。在C++代码中可以看出my_option是以如下方式被读取的。</p>

<pre><code>string value = MyMessage::descriptor()-&gt;options().GetExtension(my_option);
</code></pre>

<p>在Java代码中的读取方式如下：</p>

<pre><code>String value = MyProtoFile.MyMessage.getDescriptor().getOptions()
  .getExtension(MyProtoFile.myOption);
</code></pre>

<p>在Python中:</p>

<pre><code>value = my_proto_file_pb2.MyMessage.DESCRIPTOR.GetOptions()
  .Extensions[my_proto_file_pb2.my_option]
</code></pre>

<p>正如上面的读取方式，定制选项对于Python并不支持。定制选项在protocol buffer语言中可用于任何结构。下面就是一些具体的例子：</p>

<pre><code>import "google/protobuf/descriptor.proto";

extend google.protobuf.FileOptions {
  optional string my_file_option = 50000;
}
extend google.protobuf.MessageOptions {
  optional int32 my_message_option = 50001;
}
extend google.protobuf.FieldOptions {
  optional float my_field_option = 50002;
}
extend google.protobuf.EnumOptions {
  optional bool my_enum_option = 50003;
}
extend google.protobuf.EnumValueOptions {
  optional uint32 my_enum_value_option = 50004;
}
extend google.protobuf.ServiceOptions {
  optional MyEnum my_service_option = 50005;
}
extend google.protobuf.MethodOptions {
  optional MyMessage my_method_option = 50006;
}

option (my_file_option) = "Hello world!";

message MyMessage {
  option (my_message_option) = 1234;

  optional int32 foo = 1 [(my_field_option) = 4.5];
  optional string bar = 2;
}

enum MyEnum {
  option (my_enum_option) = true;

  FOO = 1 [(my_enum_value_option) = 321];
  BAR = 2;
}

message RequestType {}
message ResponseType {}

service MyService {
  option (my_service_option) = FOO;

  rpc MyMethod(RequestType) returns(ResponseType) {
    // Note:  my_method_option has type MyMessage.  We can set each field
    //   within it using a separate "option" line.
    option (my_method_option).foo = 567;
    option (my_method_option).bar = "Some string";
  }
}
</code></pre>

<p>注：如果要在该选项定义之外使用一个自定义的选项，必须要由包名 + 选项名来定义该选项。如：</p>

<pre><code>// foo.proto
import "google/protobuf/descriptor.proto";
package foo;
extend google.protobuf.MessageOptions {
  optional string my_option = 51234;
}
</code></pre>

<p>.</p>

<pre><code>// bar.proto
import "foo.proto";
package bar;
message MyMessage {
  option (foo.my_option) = "Hello world!";
}
</code></pre>

<p>最后一件事情需要注意：因为自定义选项是可扩展的，它必须象其它的域或扩展一样来定义标识号。正如上述示例，[50000－99999]已经被占 用，该范围内的值已经被内部所使用，当然了你可以在内部应用中随意使用。如果你想在一些公共应用中进行自定义选项，你必须确保它是全局唯一的。可以通过protobuf-global-extension-registry@google.com来获取全局唯一标识号。 只需提供你的项目名和项目网站. 通常你只需要一个扩展号。 你可以使用一个扩展号声明多个选项:</p>

<pre><code>message FooOptions {
  optional int32 opt1 = 1;
  optional string opt2 = 2;
}

extend google.protobuf.FieldOptions {
  optional FooOptions foo_options = 1234;
}

// usage:
message Bar {
  optional int32 a = 1 [(foo_options).opt1 = 123, (foo_options).opt2 = "baz"];
  // alternative aggregate syntax (uses TextFormat):
  optional int32 b = 2 [(foo_options) = { opt1: 123 opt2: "baz" }];
}
</code></pre>

<h2>生成访问类</h2>

<p>可以通过定义好的.proto文件来生成Java、Python、C++代码，需要基于.proto文件运行protocol buffer编译器protoc。运行的命令如下所示：</p>

<pre><code>protoc --proto_path=IMPORT_PATH --cpp_out=DST_DIR --java_out=DST_DIR --python_out=DST_DIR path/to/file.proto
</code></pre>

<ul>
<li><p>IMPORT_PATH声明了一个.proto文件所在的具体目录。如果忽略该值，则使用当前目录。如果有多个目录则可以 对&ndash;proto_path 写多次，它们将会顺序的被访问并执行导入。-I=IMPORT_PATH是它的简化形式。</p></li>
<li><p>当然也可以提供一个或多个输出路径：</p>

<ul>
<li>&ndash;cpp_out 在目标目录DST_DIR中产生C++代码，可以在 <a href="https://developers.google.com/protocol-buffers/docs/reference/cpp-generated?hl=zh-cn">C++ generated code reference</a>中查看更多。</li>
<li>&ndash;java_out 在目标目录DST_DIR中产生Java代码，可以在 <a href="https://developers.google.com/protocol-buffers/docs/reference/java-generated?hl=zh-cn">Java generated code reference</a>中查看更多。</li>
<li>&ndash;python_out 在目标目录 DST_DIR 中产生Python代码，可以在 <a href="https://developers.google.com/protocol-buffers/docs/reference/python-generated?hl=zh-cn">Python generated code reference</a>中查看更多。</li>
</ul>


<p>  作为一种额外的约定，如果DST_DIR 是以.zip或.jar结尾的，编译器将输出结果打包成一个zip格式的归档文件。.jar将会输出一个 Java JAR声明必须的manifest文件。注：如果该输出归档文件已经存在，它将会被重写，编译器并没有做到足够的智能来为已经存在的归档文件添加新的文 件。</p></li>
<li>你必须提供一个或多个.proto文件作为输入。多个.proto文件能够一次全部声明。虽然这些文件是相对于当前目录来命名的，每个文件必须在一个IMPORT_PATH中，只有如此编译器才可以决定它的标准名称。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Protocol Buffer Encoding]]></title>
    <link href="http://yblu.github.io/blog/2015/06/01/PB-Encoding/"/>
    <updated>2015-06-01T00:00:00+08:00</updated>
    <id>http://yblu.github.io/blog/2015/06/01/PB-Encoding</id>
    <content type="html"><![CDATA[<p>这篇文章描述了protocol buffre消息的二进制有序格式。使用protocol buffers不需要理解这些，但是理解这些能够帮助你了解不同的protocol buffer格式是如何影响你的消息的编码。</p>

<h2>一个简单的消息</h2>

<p>定义以下一个简单的消息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>message Test1 {
</span><span class='line'>  required int32 a = 1;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在应用程序中，你可以创建一个Test1 消息，然后设置它的值为150。然后你将该消息序列化得到一个输出流。如果你可以查看编码过的消息，会看到 以下3 byte：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>88 96 01</span></code></pre></td></tr></table></div></figure>


<h2>Base 128 Varint</h2>

<p>Varint 是一种紧凑的表示数字的方法。它用一个或多个字节来表示一个数字，值越小的数字使用越少的字节数。这能减少用来表示数字的字节数。
比如对于 int32 类型的数字，一般需要 4 个 byte 来表示。但是采用 Varint，对于很小的 int32 类型的数字，则可以用 1 个 byte 来表示。当然凡事都有好的也有不好的一面，采用 Varint 表示法，大的数字则需要 5 个 byte 来表示。从统计的角度来说，一般不会所有的消息中的数字都是大数，因此大多数情况下，采用 Varint 后，可以用更少的字节数来表示数字信息。下面就详细介绍一下 Varint。</p>

<p>Varint 中的每个 byte 的最高位 bit 有特殊的含义，如果该位为 1，表示后续的 byte 也是该数字的一部分，如果该位为 0，则结束。其他的 7 个 bit 都用来表示数字。因此小于 128 的数字都可以用一个 byte 表示。大于 128 的数字，比如 300，会用两个字节来表示：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1010 1100 0000 0010</span></code></pre></td></tr></table></div></figure>


<h2>Message Structure</h2>

<p>protocol buffer是 一系列的 key-value 对。二进制消息只是用他们的域的数值来作为他们的key——可以有message 类型唯一解析的域名和域的类型。
消息被编码的时候，key和value都会被串连到一个字节流汇总。当消息被解析的时候，解析器能够跳过它不能识别的域。通过这种方式，新的域能过被添加到一条消息里面，同时不破坏不能解析它们的老程序。为了这个目的，每对的key其实是两个值得组合——域的数值和wire type（能够提供足够信息找到后面value的长度）</p>

<div class="devsite-table-wrapper"><table width="50%" border="1">
<tbody><tr><th>Type</th><th>Meaning</th><th>Used For</th></tr>
<tr><td>0</td><td>Varint</td><td>int32, int64, uint32, uint64, sint32, sint64, bool, enum</td></tr><tr>
</tr><tr><td>1</td><td>64-bit</td><td>fixed64, sfixed64, double</td></tr><tr>
</tr><tr><td>2</td><td>Length-delimited</td><td>string, bytes, embedded messages, packed repeated fields</td></tr><tr>
</tr><tr><td>3</td><td>Start group</td><td>groups (deprecated)</td></tr><tr>
</tr><tr><td>4</td><td>End group</td><td>groups (deprecated)</td></tr><tr>
</tr><tr><td>5</td><td>32-bit</td><td>fixed32, sfixed32, float</td></tr><tr>
</tr></tbody></table></div>


<p>Key 用来标识具体的 field，在解包的时候，Protocol Buffer 根据 Key 就可以知道相应的 Value 应该对应于消息中的哪一个 field。
Key 的定义如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> (field_number &lt;&lt; 3) | wire_type</span></code></pre></td></tr></table></div></figure>


<p>可以看到 Key 由两部分组成。最后3 bit是用来存储wire type。第一部分是 field_numbe。第二部分为 wire_type。表示 Value 的传输类型。
再来看一个简单的例子。一条消息的第一个数字总是varint key，是08，或者如下（去掉msb）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>000 1000</span></code></pre></td></tr></table></div></figure>


<p>去最后三位得到wire type 0，然后右移三位得到 field number 1.因为你知道tag是1，加下来的value是varint。使用前面描述的varint解码，得到后续两个字节存储的是150.</p>

<blockquote><p>96 01 = 1001 0110  0000 0001
       → 000 0001  ++  001 0110 (drop the msb and reverse the groups of 7 bits)
       → 10010110
       → 2 + 4 + 16 + 128 = 150</p></blockquote>

<p>在计算机内，一个负数一般会被表示为一个很大的整数，因为计算机定义负数的符号位为数字的最高位。如果采用 Varint 表示一个负数，那么一定需要 5 个 byte。为此 Google Protocol Buffer 定义了 sint32 这种类型，采用 zigzag 编码。
Zigzag 编码用无符号数来表示有符号数字，正数和负数交错，这就是 zigzag 这个词的含义了。
如下表所示：</p>

<div class="devsite-table-wrapper"><table width="50%" border="1">
<tbody><tr><th>Signed Original</th><th>Encoded As</th></tr>
<tr><td>0</td><td>0</td></tr><tr>
</tr><tr><td>-1</td><td>1</td></tr><tr>
</tr><tr><td>1</td><td>2</td></tr><tr>
</tr><tr><td>-2</td><td>3</td></tr><tr>
</tr><tr><td>2147483647</td><td>4294967294</td></tr><tr>
</tr><tr><td>-2147483648</td><td>4294967295</td></tr><tr>
</tr></tbody></table></div>


<p>也可以理解成，对于sint32，每个值 n 被编码成</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(n &lt;&lt; 1) ^ (n &gt;&gt; 31)</span></code></pre></td></tr></table></div></figure>


<p>对于sint64</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(n &lt;&lt; 1) ^ (n &gt;&gt; 63)</span></code></pre></td></tr></table></div></figure>


<p> 注意到第二个因为是算数移位。其实也就是，移位的结果要么全是0（n 是正数）要么全是1（n 是负数）
当 sint32 或sint64 被解析的时候，他的value被解码成原来的带符号的版本。</p>

<h3>非 varint 数字</h3>

<p>非 varint 数值类型比较简单，double 和 fixed64 的wire type为1，这告诉解析器这是一个固定为64 bit 的数据块。类似的，float 和 fixed64 的 wire type 为5，这说明就是32 bit的。这两种类型的都是采用 little-endian 的存储方式。</p>

<h3>String</h3>

<p>一个 wire type 2移位这个这个value是varint 编码，后面跟着一序列的特殊数据的字节。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>message Test2 {
</span><span class='line'>  required string b = 2;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>设置b成“testing”，则有：</p>

<blockquote><p>12 07 <strong>74 65 73 74 69 6e 67</strong></p></blockquote>

<p>加粗部分为”testing“的UTF-8编码，key 为 0x12 → tag = 2, type = 2。value的 varint 长度为7。</p>

<h3>嵌套消息</h3>

<p>定义如下一个嵌套消息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>message Test3 {
</span><span class='line'>  required Test1 c = 3;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Test1的域 a 被设置成150，则编码过后得到：</p>

<blockquote><p>1a 03 <strong>08 96 01</strong>
后三位 08 96 01 正好是前面150的编码，数字3在他们前面，嵌套消息被看成是string。</p></blockquote>

<h3>可选项和重复元素</h3>

<p>如果你定义的message拥有repeated成员（没有选项[packed = true]），那么编码的消息有零到多个相同tag的key-value对。这些repeated values 不一定连续。他们可能和其他字段交错。这写元素彼此的相对位置在解析的时候会被保留，然后和其他域的相对位置会丢失。</p>

<p>如果有optionan成员，tag对应的key-value对可能有，也可能没有。</p>

<p>通常，一个编码的消息不会有多余一个的optional或required的示例。然后解析器也能处理多余一个情况。对于数值类型和字符串，如果相同的value出现多次，他们将接受它认为的最后一个value。对于嵌套消息的字段，解析器合并相同域的多个实例，就像用<code>Message::MergeFrom</code>，所有的单一标量字段将有后来代替先来的。单一个嵌套message会被合并，重复的字段被串连在一起。这些规则保证了间歇两个嵌套的消息的结果和你单独分开解析两个消息然后合并他们的结果是一致的。示例如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">MyMessage</span> <span class="n">message</span><span class="p">;</span>
</span><span class='line'><span class="n">message</span><span class="p">.</span><span class="n">ParseFromString</span><span class="p">(</span><span class="n">str1</span> <span class="o">+</span> <span class="n">str2</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>等价于：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">MyMessage</span> <span class="n">message</span><span class="p">,</span> <span class="n">message2</span><span class="p">;</span>
</span><span class='line'><span class="n">message</span><span class="p">.</span><span class="n">ParseFromString</span><span class="p">(</span><span class="n">str1</span><span class="p">);</span>
</span><span class='line'><span class="n">message2</span><span class="p">.</span><span class="n">ParseFromString</span><span class="p">(</span><span class="n">str2</span><span class="p">);</span>
</span><span class='line'><span class="n">message</span><span class="p">.</span><span class="n">MergeFrom</span><span class="p">(</span><span class="n">message2</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个性质比较有用，因为他允许你合并两个消息，尽管你不知道他们的类型。</p>

<p>Packed Repeated Fields
Version 2.1.0引入了packed repeated 字段，带有选项[packed=true]的repeated字段。这个功能像repeated字段，但编码不同。0个元素的Packed Repeated  字段不会出现在编码消息中。否则，所有的字段元素都会被打包成成一个key-value对，wire type 为2。 每个元素都会以同样的方式编码，除了没有tag在他们前面。
例如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">message</span> <span class="n">Test4</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">repeated</span> <span class="n">int32</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">4</span> <span class="p">[</span><span class="n">packed</span><span class="o">=</span><span class="nb">true</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>假设Test4 的字段d有值有3,270和86942，则编码形式如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="mi">22</span>        <span class="c1">// tag (field number 4, wire type 2)</span>
</span><span class='line'><span class="mo">06</span>        <span class="c1">// payload size (6 bytes)</span>
</span><span class='line'><span class="mo">03</span>        <span class="c1">// first element (varint 3)</span>
</span><span class='line'><span class="mi">8</span><span class="n">E</span> <span class="mo">02</span>     <span class="c1">// second element (varint 270)</span>
</span><span class='line'><span class="mi">9</span><span class="n">E</span> <span class="n">A7</span> <span class="mo">05</span>  <span class="c1">// third element (varint 86942)</span>
</span></code></pre></td></tr></table></div></figure>


<p>只有原始数值类型的repeated字段可以有“packed”。
注意到尽管一般没有理由编码更多的key-value对给一个packed repeated字段。编码器必须准备应复合key-value对。在这种情况下，负荷必须边串连进去。每对必须包含所有所有元素。</p>

<h2>字段顺序</h2>

<p>在.proto文件中使字段可以是任意顺序的，当一条消息被序列化的时候，它所知道的字段是会根据字段标号顺序写入，就像C++，Java，Python的序列化代码。这允许解析代码可以根据有序的字段标号进行进行优化。然后protocol buffer 的解析器必须是能够解析任意顺序的字段，因为并非所有的消息都是被建成有序的对象，例如，这有时对简单串联合并的两个消息很有用。</p>

<p>如果一个消息的拥有未知字段，现有Java 和C++ 操作在完成其他已知字段的序列化后将他们以任意顺序写入。现有的Python追踪未知字段。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Php 抽奖算法]]></title>
    <link href="http://yblu.github.io/blog/2015/05/28/php-lottery/"/>
    <updated>2015-05-28T00:00:00+08:00</updated>
    <id>http://yblu.github.io/blog/2015/05/28/php-lottery</id>
    <content type="html"><![CDATA[<p>今天股票大跌，黑色星期四。</p>

<p>今天写了一个用来负载均衡程序，抽象一下可以看成就是一抽奖程序。</p>

<p>现在A股也想抽奖，就应景一下把这程序记录一下，其实很简单，直接贴代码。</p>

<pre><code>function get_rand($proArr) { 
    $result = ''; 
    //概率数组的总概率精度 
    $proSum = array_sum($proArr); 
    //概率数组循环 
    foreach ($proArr as $key =&gt; $proCur) { 
        $randNum = mt_rand(1, $proSum);             //抽取随机数
        if ($randNum &lt;= $proCur) { 
            $result = $key;                         //得出结果
            break; 
        } else { 
            $proSum -= $proCur;                     
        } 
    } 
    unset ($proArr); 
    return $result; 
}
</code></pre>

<p>这段代码能够实现抽奖功能，当比较难从数学上证明正好服从设置的概率分布（有待证明,样本空间不变因此概率是一样的，有待补充。）</p>

<p>写成这样，思维上比较顺。</p>

<pre><code>function get_rand($arr)
{
    $pro_sum=array_sum($arr);
    $rand_num=mt_rand(1,$pro_sum);
    $tmp_num=0;
    foreach($arr as $k=&gt;$val)
    {    
        if($rand_num&lt;=$val+$tmp_num)
        {
            $n=$k;
            break;
        }else
        {
            $tmp_num+=$val;
        }
    }
    return $n;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MapReduce 的优化Tips]]></title>
    <link href="http://yblu.github.io/blog/2015/05/20/MR-optimization/"/>
    <updated>2015-05-20T00:00:00+08:00</updated>
    <id>http://yblu.github.io/blog/2015/05/20/MR-optimization</id>
    <content type="html"><![CDATA[<p>最近在都做MapReduce，但是MapReduce没有想象中处理数据这么快，结果发现并不能盲目的使用MapReduce。MapReduce是可以许多机器同时计算，但是并行计算带来的性能提升是有限的，有事反而会因为使用MapReduce过于简单粗暴，不根据具体的业务场景做适当的优化，反而会使程序性能下降。下面以最近的一个任务的完成为线索，将最近学习到的优化经验总结一下。</p>

<h2>任务场景</h2>

<ul>
<li>数据A：包含url、ip、cookie、id、pv等数据</li>
<li>数据B：ip字典（ip到地区的id映射）</li>
<li>要求：以site*ip为统计粒度，计算数据分布，并且需要在数据里拼接上id</li>
<li>目的：分析不同地区是否方位不同站点的偏好，去掉无法查到地区ip的数据</li>
</ul>


<h3>Mapreduce程序设计</h3>

<p>以url和ip为key，ip为partition，在reduce阶段进行数据合并</p>

<ul>
<li><p>Map1输出：<code>(key:&lt;ip1,url1&gt;,vaule:pv1)</code></p></li>
<li><p>Map2输出：<code>(key:&lt;ip2,"", vaule:locationid)</code></p></li>
<li><p>Reducer输出：<code>（ip, url, locationid, total_pv)</code></p></li>
</ul>


<h3>性能优化</h3>

<ul>
<li><p>在map阶段加上combiner，减少从map到reducer传输的数据量</p></li>
<li><p>在map的task中开辟一块内存，构造一个cache，代替combiner的工作</p></li>
<li><p>对ip数据进行采样，计算出合理的分桶方法，重写并设置partition</p>

<ul>
<li>从100条数据中抽取一天数据</li>
<li>将ip转化为数字进行排序</li>
<li>划分区间</li>
</ul>
</li>
<li><p>如果ip字典很小，不采用reduce合并的方法，在map阶段，加载ip字典到内存中，直接查询。</p></li>
<li><p>如果ip字典很大，但是很多ip在字典中查不到。仍采用reduce阶段合并，预先计算一个ip的bloomfilter，用于在map阶段过来数据。</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[++i 和 I++ 的效率对比]]></title>
    <link href="http://yblu.github.io/blog/2015/05/13/++iandi++/"/>
    <updated>2015-05-13T00:00:00+08:00</updated>
    <id>http://yblu.github.io/blog/2015/05/13/++iandi++</id>
    <content type="html"><![CDATA[<p>这个问题需要分两种情况来解说：</p>

<p>1、当变量i的数据类型是c++语言默认提供的类型的话，他们的效率是一样的。</p>

<p>int a,i=0;     a=++i;汇编代码如下：</p>

<pre><code> int a,i=0;
01221A4E  mov         dword ptr [i],0 
 a=++i;
01221A55  mov         eax,dword ptr [i] 
01221A58  add         eax,1 
01221A5B  mov         dword ptr [i],eax 
01221A5E  mov         ecx,dword ptr [i] 
01221A61  mov         dword ptr [a],ecx
</code></pre>

<p>int a,i=0;     a=i++;汇编代码如下：</p>

<pre><code>  int a,i=0;
009E1A4E  mov         dword ptr [i],0 
 a=i++;
009E1A55  mov         eax,dword ptr [i] 
009E1A58  mov         dword ptr [a],eax 
009E1A5B  mov         ecx,dword ptr [i] 
009E1A5E  add         ecx,1 
009E1A61  mov         dword ptr [i],ecx
</code></pre>

<p>从汇编代码可以看出，他们的执行行数是一样的！</p>

<p> 2、我们自定的数据类型，++i效率高于i++，通过运算符重载来给大家说明这一点。</p>

<pre><code>Operator Operator::operator++()
{
   ++value;    //内部成员变量
   return *this;
}

Operator Operator::operator++(int)
{
 Operator temp;
 temp.value=value;
 value++;
 return temp;
}
</code></pre>

<p>后++必须要有一个临时对象才可以</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Protocol Buffers Overview]]></title>
    <link href="http://yblu.github.io/blog/2015/05/07/PB-Overview/"/>
    <updated>2015-05-07T00:00:00+08:00</updated>
    <id>http://yblu.github.io/blog/2015/05/07/PB-Overview</id>
    <content type="html"><![CDATA[<h2>Protocol Buffers(PB)简介</h2>

<p>protocol buffers是google提供的一种将结构化数据进行序列化和反序列化的方法，其优点是语言中立，平台中立，可扩展性好，目前在google内部大量用于数据存储，通讯协议等方面。PB在功能上类似XML，但是序列化后的数据更小，解析更快，使用上更简单。用户只要按照proto语法在.proto文件中定义好数据的结构，就可以使用PB提供的工具（protoc）自动生成处理数据的代码，使用这些代码就能在程序中方便的通过各种数据流读写数据。PB目前支持Java, C++和Python3种语言。另外，PB还提供了很好的向后兼容，即旧版本的程序可以正常处理新版本的数据，新版本的程序也能正常处理旧版本的数据。</p>

<blockquote><p>Protocol buffers are Google’s language-neutral, platform-neutral, extensible mechanism for serializing structured data – think XML, but smaller, faster, and simpler. You define how you want your data to be structured once, then you can use special generated source code to easily write and read your structured data to and from a variety of data streams and using a variety of languages – Java, C++, or Python. You can even update your data structure without breaking deployed programs that are compiled against the “old” format.（摘自<a href="https://developers.google.com/protocol-buffers/docs/overview?hl=zh-cn">PB官网</a>）</p></blockquote>

<h2>如何使用Protocol Buffers</h2>

<ol>
<li><p>定义一个.proto文件</p>

<p> 在addressbook.proto文件里定义通讯簿消息的格式，一个通讯簿（AddressBook）由可重复的Person组成，一个person由两个必需存在的name和id字段，以及一个可选的email字段，和可重复的PhoneNumber构成。PhoneNumber由number和type组成。</p>

<pre><code> message Person {
     required string name = 1;
     required int32 id = 2;
     optional string email = 3;

     enum PhoneType {
         MOBILE = 0;
         HOME = 1;
         WORK = 2;
     }

     message PhoneNumber {
         required string number = 1;
         optional PhoneType type = 2 [default = HOME];
     }

     repeated PhoneNumber phone = 4;
 }
</code></pre></li>
<li><p>使用protocol编译器</p>

<p> 使用PB使用的工具Protocol根据.proto文件自动生成处理消息的代码</p>

<pre><code> protoc -I=$SRC_DIR --cpp_out=$DST_DIR $SRC_DIR/addressbook.proto
</code></pre>

 在$DST_DIR里生成了下面两个文件：

<blockquote><p>addressbook.pb.h
<br>
addressbook.pb.cc</p></blockquote></li>
<li><p>使用PB的API来写入和读取messages</p>

<p> 程序使用生成的代码来读写（序列化，反序列化）和操作（get，set）消。</p>

<p> 写的代码：</p>

<pre><code> Person person;
 person.set_name("John Doe");
 person.set_id(1234);
 person.set_email("jdoe@example.com");
 fstream output("myfile", ios::out | ios::binary);
 person.SerializeToOstream(&amp;output);
</code></pre>

<p> 读的代码：</p>

<pre><code> fstream input("myfile", ios::in | ios::binary);
 Person person;
 person.ParseFromIstream(&amp;input);
 cout &lt;&lt; "Name: " &lt;&lt; person.name() &lt;&lt; endl;
 cout &lt;&lt; "E-mail: " &lt;&lt; person.email() &lt;&lt; endl;
</code></pre></li>
</ol>


<h2>why not just use XML</h2>

<p>相比XML在序列化结构语言上protocol buffers有以下特点：</p>

<ul>
<li>更简单</li>
<li>体积上小3~10倍</li>
<li>速度上快20~100倍</li>
<li>定义更清晰</li>
<li>更容易通过程序产生数据接入类</li>
</ul>


<p>例如，你想简历一个模型person，它有name和email。在XML中，你需要这样做：</p>

<pre><code>&lt;person&gt;
&lt;name&gt;John Doe&lt;/name&gt;
&lt;email&gt;jdoe@example.com&lt;/email&gt;
&lt;/person&gt;
</code></pre>

<p>然而相应的protocol buffer的message是这样的：</p>

<pre><code># Textual representation of a protocol buffer.
# This is *not* the binary format used on the wire.
person {
    name: "John Doe"
    email: "jdoe@example.com"
}
</code></pre>

<p>这条message被编码成protocol buffer 二进制格式（上述文本格式只是便于人类可读性表达，更利于调试和修改），它可能只是28 byte长，只需要100~200ns来解析。而XML的版本如果扣除空白部分可能需要69 byte，将需要5,000~10,000ns来解析。
另外，操作一个protocol buffer更容易：</p>

<pre><code>cout &lt;&lt; "Name: " &lt;&lt; person.name() &lt;&lt; endl;
cout &lt;&lt; "E-mail: " &lt;&lt; person.email() &lt;&lt; endl;
</code></pre>

<p>然而XML需要这样解析：</p>

<pre><code>cout &lt;&lt; "Name: "
     &lt;&lt; person.getElementsByTagName("name")-&gt;item(0)-&gt;innerText()
     &lt;&lt; endl;
cout &lt;&lt; "E-mail: "
     &lt;&lt; person.getElementsByTagName("email")-&gt;item(0)-&gt;innerText()
     &lt;&lt; endl;
</code></pre>

<p>不过，protocol buffer也不是总比XML是个解决方案，例如protocol buffer不能很好的对一个基于文档标记的文本进行建模（如 HTML），因为你不能交错文本结构。另外XML可读性和可编辑性更强。protocol buffer至少在他们的原始格式是并不是。XML同时也是可扩展，自描述的。Protocol buffer只有提供了message描述文件.proto 文件才有意义。</p>

<h2>A bit of history</h2>

<p>Protocol Buffer一开始在google是为了处理一个索引服务器请求/响应协议。在Protocol Buffer之前，请求和响应一个用来请求/响应的封装或解封的格式，它支持大量版本的协议。它是通过非常丑陋的代码来解决的，像下面这样：</p>

<pre><code>if (version == 3) {
...
} else if (version &gt; 4) {
    if (version == 5) {
    ...
    }
...
}
</code></pre>

<p>显然，格式化协议使得采用新的协议的版本上线更复杂，因为开发者必须确保请求发起服务器和实际处理这些请求的服务器中间经过的所有服务器在他们切换到开始使用新协议之前能够理解新协议。
Protocol Buffer就是来解决这样许多这样的问题：</p>

<ul>
<li>新的域能够很容易的引入。中间服务器不需要注入数据就能简单地解析他，并且不需要了解所有的域就可以传输数据。</li>
<li>格式要能够自描述，能够处理各种类型的编程语言（C++,java,etc）</li>
</ul>


<p>然而，用户仍然要手写他们自己的解析代码。
因为系统升级，有大量的特性和用途：</p>

<ul>
<li>自动化产生序列化和反序列化代码，避免手动解析。</li>
<li>另外对于短生命周期的RPC请求，人们开始使用protocol buffers 作为一种手动的自描述格式来短期存储数据（例如在，Bigtable中）</li>
<li>服务器RPC 接口开始成为protocl文件的一部分，protocol编译器产生存根类，用户可以重写服务器端接口实际的操作。</li>
</ul>


<p>protocol buffer现在是Google数据的通用语，在google代码树中通过12,183个 .proto文件定义了48,162种不同的message类型。他们被应用在RPC系统和各种存储系统的各种短期存储中。</p>

<h2>proto3</h2>

<p>最新的version 3 <a href="https://github.com/google/protobuf/releases">发布页</a>  介绍了一个 新语言版本——Protocol Buffers language version 3（aka proto3），同时现有版本的语言（aka proto2）增加了很多新特性。Proto3简化了protocol buffer语言，同时简化了使用，使得可以应用在更广泛的编程语言:现有的支持Java，C++，Python，JavaNano和Ruby，和一些限制。另外最新版的proto3通过Go protoc插件支持Go。更多的语言支持正在进行中。
只在以下情况建议使用proto3:
* 如果你想在只有新版本支持的语言中使用protocol buffers。
* 如果你想尝试新的开源RPC操作gRPC，我们建议对所有的新gRPC服务器和客服端中使用proto3，因为他避免了兼容性问题。</p>

<p>注意到这两个版本的API不是完全兼容。为了避免给现有用户带来不便，我们需要在新的protocol buffers发布中继续支持已有的语言版本。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux Shell的标准输入、输出和错误]]></title>
    <link href="http://yblu.github.io/blog/2015/04/07/linux-stdio/"/>
    <updated>2015-04-07T00:00:00+08:00</updated>
    <id>http://yblu.github.io/blog/2015/04/07/linux-stdio</id>
    <content type="html"><![CDATA[<h2>1、文件描述符</h2>

<table border="1">
    <tr>
        <td>文件</td>
        <td>文件描述符</td>
    </tr>
    <tr>
        <td>输入文件——标准输入</td>
        <td>0(缺省是键盘，为0时是文件后者其他命令输出)</td>
    <tr>
        <td>输出文件——标准输出</td>
        <td>1(缺省的是屏幕，为1时文件）</td>
    </tr>
    <tr>
        <td>错误输出文件</td>
        <td>2（缺省的是屏幕，为2是文件）</td>
    </tr>
</table>


<h2>2、文件重定向</h2>

<h3>2.1 输出重定向</h3>

<table border="1">
    <tr>
        <td>cmd > filename</td>
        <td>把标准输出重定向到一个新文件中（如果文件不存在则新建，如果文件存在则覆盖</td>
    </tr>
    <tr>
        <td>cmd >> filename</td>
        <td>把标准输出重定向到一个文件中（追加）</td>
    </tr>
    <tr>
        <td>cmd > filename 2>&1</td>
        <td>把标准输出和错误一起重定向到一个文件中</td>
    </tr>
    <tr>
        <td>cmd 2 > filename</td>
        <td>把标准错误重定向到一个文件中</td>
    </tr>
    <tr>
        <td>cmd 2 >> filename</td>
        <td>把标准错误重定向追加到一个文件中</td>
    </tr>
    <tr>
        <td>cmd >> filename 2>&1</td>
        <td>把标准输出和错误重定向追加到一个文件中</td>
    </tr>
</table>


<h3>2.2 输入重定向</h3>

<table border="1">
    <tr>
        <td>cmd < filename > filename2</td>
        <td>cmd的命令以 filename 文件作为标准输入，以 filename2 作为作为标准输出</td>
    </tr>
    <tr>
        <td>cmd < filename</td>
        <td>cmd命令以 filename 文件作为标准输入</td>
    </tr>
    <tr>
        <td>cmd << delimiter</td>
        <td>从标准输入中读入，直到遇到delimiter分界符</td>
    </tr>
</table>


<h3>2.3 绑定重定向</h3>

<table>
    <tr>
        <td>cmd > &m</td>
        <td>把标准输出重定向到文件描述符中</td>
    </tr>
    <tr>
        <td>cmd < &-</td>
        <td>关闭标准输入</td>
    </tr>
    <td>cmd 0 > &-</td>
    <td>g关闭标准输入</td>
</table>


<h2>3 shell重定向的一些高级用法</h2>

<h3>3.1 重定向标准错误</h3>

<p>例子1：</p>

<pre><code>command 2&gt; /dev/null
</code></pre>

<p>如果command执行出错，将错误的信息重定向到空设备</p>

<p>例子2：</p>

<pre><code>command &gt; out.put 2&gt;&amp;1
</code></pre>

<p>将command执行的标准输出和标准错误重定向到out.put（也就是说不管command执行正确还是错误，输出都打印到out.put）。</p>

<h3>3.2 exec用法</h3>

<p>exec命令可以用来替代当前shell；换句话说，并没有启动子shell，使用这一条命令时任何现有环境变量将会被清除，并重新启动一个shell（重新输入用户名和密码进入）。</p>

<pre><code>exec command
</code></pre>

<p>其中，command通常是一个shell脚本。</p>

<p>对文件描述符操作的时候用（也只有再这时候），它不会覆盖你当前的shell</p>

<p>例子1：</p>

<pre><code>#!/bin/bash
#file_desc
exec 3&lt;&amp;0 0&lt;name.txt
read line1
read line2
exec 0&lt;&amp;3
echo $line1
echo $line2
</code></pre>

<p>其中：
首先，<code>exec 3&lt;&amp;0 0&lt;name.txt</code>的意思是把标准输入重定向到文件描述符3（0表示标准输入），然后把文件name.txt内容重定向到文件描述符0，实际上就是把文件name.txt中的内容重定向到文件描述符3。然后通过exec打开文件描述符3；
然后，通过read命令读取name.txt的第一行内容line1，第二行内容line2，通过Exec 0&lt;&amp;3关闭文件描述符3；
最后，用echo命令输出line1和line2。最好在终端运行一下这个脚本，亲自尝试一下。</p>

<p>例子2：</p>

<pre><code>exec 3&lt;&gt;test.sh;
#打开test.sh可读写操作，与文件描述符3绑定
while read line&lt;&amp;3
do
    echo $line;
done
#循环读取文件描述符3（读取的是test.sh内容）
exec 3&gt;&amp;-
exec 3&lt;&amp;-
#关闭文件的，输入，输出绑定
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hadoop FS Shell命令]]></title>
    <link href="http://yblu.github.io/blog/2015/04/03/hadoop-fs%20shell/"/>
    <updated>2015-04-03T00:00:00+08:00</updated>
    <id>http://yblu.github.io/blog/2015/04/03/hadoop-fs shell</id>
    <content type="html"><![CDATA[<h2>FS Shell</h2>

<p>调用文件系统(FS)Shell命令应使用 bin/hadoop fs <args>的形式。 所有的的FS shell命令使用URI路径作为参数。URI格式是scheme://authority/path。对HDFS文件系统，scheme是hdfs，对本地文件系统，scheme是file。其中scheme和authority参数都是可选的，如果未加指定，就会使用配置中指定的默认scheme。一个HDFS文件或目录比如/parent/child可以表示成hdfs://namenode:namenodeport/parent/child，或者更简单的/parent/child（假设你配置文件中的默认值是namenode:namenodeport）。大多数FS Shell命令的行为和对应的Unix Shell命令类似，不同之处会在下面介绍各命令使用详情时指出。出错信息会输出到stderr，其他信息输出到stdout。</p>

<h3>cat</h3>

<p>使用方法：<code>hadoop fs -cat URI [URI …]</code></p>

<p>将路径指定文件的内容输出到stdout。</p>

<p>示例：</p>

<ul>
<li><p><code>hadoop fs -cat hdfs://host1:port1/file1 hdfs://host2:port2/file2</code></p></li>
<li><p><code>hadoop fs -cat file:///file3 /user/hadoop/file4</code></p></li>
</ul>


<p>返回值：
成功返回0，失败返回-1。</p>

<h3>chgrp</h3>

<p>使用方法：<code>hadoop fs -chgrp [-R] GROUP URI [URI …]</code></p>

<p>改变文件所属的组。使用-R将使改变在目录结构下递归进行。命令的使用者必须是文件的所有者或者超级用户。更多的信息请参见HDFS权限用户指南。</p>

<h3>chmod</h3>

<p>使用方法：<code>hadoop fs -chmod [-R] &lt;MODE[,MODE]... | OCTALMODE&gt; URI [URI …]</code></p>

<p>改变文件的权限。使用-R将使改变在目录结构下递归进行。命令的使用者必须是文件的所有者或者超级用户。更多的信息请参见HDFS权限用户指南。</p>

<h3>chown</h3>

<p>使用方法：<code>hadoop fs -chown [-R] [OWNER][:[GROUP]] URI [URI ]</code></p>

<p>改变文件的拥有者。使用-R将使改变在目录结构下递归进行。命令的使用者必须是超级用户。更多的信息请参见HDFS权限用户指南。</p>

<h3>copyFromLocal</h3>

<p>使用方法：<code>hadoop fs -copyFromLocal &lt;localsrc&gt; URI</code></p>

<p>除了限定源路径是一个本地文件外，和put命令相似。</p>

<h3>copyToLocal</h3>

<p>使用方法：<code>hadoop fs -copyToLocal [-ignorecrc] [-crc] URI &lt;localdst&gt;</code></p>

<p>除了限定目标路径是一个本地文件外，和get命令类似。</p>

<h3>cp</h3>

<p>使用方法：<code>hadoop fs -cp URI [URI …] &lt;dest&gt;</code></p>

<p>将文件从源路径复制到目标路径。这个命令允许有多个源路径，此时目标路径必须是一个目录。</p>

<p>示例：</p>

<ul>
<li><code>hadoop fs -cp /user/hadoop/file1 /user/hadoop/file2</code></li>
<li><code>hadoop fs -cp /user/hadoop/file1 /user/hadoop/file2 /user/hadoop/dir</code></li>
</ul>


<p>返回值：</p>

<p>成功返回0，失败返回-1。</p>

<h3>du</h3>

<p>使用方法：<code>hadoop fs -du URI [URI …]</code></p>

<p>显示目录中所有文件的大小，或者当只指定一个文件时，显示此文件的大小。</p>

<p>示例：</p>

<ul>
<li><code>hadoop fs -du /user/hadoop/dir1 /user/hadoop/file1 hdfs://host:port/user/hadoop/dir1</code></li>
</ul>


<p>返回值：</p>

<p>成功返回0，失败返回-1。</p>

<h3>dus</h3>

<p>使用方法：<code>hadoop fs -dus &lt;args&gt;</code></p>

<p>显示文件的大小。</p>

<h3>expunge</h3>

<p>使用方法：<code>hadoop fs -expunge</code></p>

<p>清空回收站。请参考HDFS设计文档以获取更多关于回收站特性的信息。</p>

<h3>get</h3>

<p>使用方法：hadoop fs -get [-ignorecrc] [-crc] <src> <localdst></p>

<p>复制文件到本地文件系统。可用-ignorecrc选项复制CRC校验失败的文件。使用-crc选项复制文件以及CRC信息。</p>

<p>示例：</p>

<ul>
<li><p><code>hadoop fs -get /user/hadoop/file localfile</code></p></li>
<li><p><code>hadoop fs -get hdfs://host:port/user/hadoop/file localfile</code></p></li>
</ul>


<p>返回值：</p>

<p>成功返回0，失败返回-1。</p>

<h3>getmerge</h3>

<p>使用方法：<code>hadoop fs -getmerge &lt;src&gt; &lt;localdst&gt; [addnl]</code></p>

<p>接受一个源目录和一个目标文件作为输入，并且将源目录中所有的文件连接成本地目标文件。addnl是可选的，用于指定在每个文件结尾添加一个换行符。</p>

<h3>ls</h3>

<p>使用方法：<code>hadoop fs -ls &lt;args&gt;</code></p>

<p>如果是文件，则按照如下格式返回文件信息：</p>

<p>文件名 &lt;副本数> 文件大小 修改日期 修改时间 权限 用户ID 组ID</p>

<p>如果是目录，则返回它直接子文件的一个列表，就像在Unix中一样。目录返回列表的信息如下：</p>

<p>目录名 &lt;dir> 修改日期 修改时间 权限 用户ID 组ID</p>

<p>示例：</p>

<ul>
<li><code>hadoop fs -ls /user/hadoop/file1 /user/hadoop/file2 hdfs://host:port/user/hadoop/dir1 /nonexistentfile</code></li>
</ul>


<p>返回值：</p>

<p>成功返回0，失败返回-1。</p>

<h3>lsr</h3>

<p>使用方法：<code>hadoop fs -lsr &lt;args&gt;</code></p>

<p>ls命令的递归版本。类似于Unix中的ls -R。</p>

<h3>mkdir</h3>

<p>使用方法：<code>hadoop fs -mkdir &lt;paths&gt;</code></p>

<p>接受路径指定的uri作为参数，创建这些目录。其行为类似于Unix的mkdir -p，它会创建路径中的各级父目录。</p>

<p>示例：</p>

<ul>
<li><code>hadoop fs -mkdir /user/hadoop/dir1 /user/hadoop/dir2</code></li>
<li><code>hadoop fs -mkdir hdfs://host1:port1/user/hadoop/dir hdfs://host2:port2/user/hadoop/dir</code></li>
</ul>


<p>返回值：</p>

<p>成功返回0，失败返回-1。</p>

<h3>movefromLocal</h3>

<p>使用方法：<code>dfs -moveFromLocal &lt;src&gt; &lt;dst&gt;</code></p>

<p>输出一个”not implemented“信息。</p>

<h3>mv</h3>

<p>使用方法：<code>hadoop fs -mv URI [URI …] &lt;dest&gt;</code></p>

<p>将文件从源路径移动到目标路径。这个命令允许有多个源路径，此时目标路径必须是一个目录。不允许在不同的文件系统间移动文件。</p>

<p>示例：</p>

<ul>
<li><code>hadoop fs -mv /user/hadoop/file1 /user/hadoop/file2</code></li>
<li><code>hadoop fs -mv hdfs://host:port/file1 hdfs://host:port/file2 hdfs://host:port/file3 hdfs://host:port/dir1</code></li>
</ul>


<p>返回值：</p>

<p>成功返回0，失败返回-1。</p>

<h3>put</h3>

<p>使用方法：<code>hadoop fs -put &lt;localsrc&gt; ... &lt;dst&gt;</code></p>

<p>从本地文件系统中复制单个或多个源路径到目标文件系统。也支持从标准输入中读取输入写入目标文件系统。</p>

<ul>
<li><code>hadoop fs -put localfile /user/hadoop/hadoopfile</code></li>
<li><code>hadoop fs -put localfile1 localfile2 /user/hadoop/hadoopdir</code></li>
<li><code>hadoop fs -put localfile hdfs://host:port/hadoop/hadoopfile</code></li>
<li><code>hadoop fs -put hdfs://host:port/hadoop/hadoopfile</code></li>
</ul>


<p>从标准输入中读取输入。</p>

<p>返回值：</p>

<p>成功返回0，失败返回-1。</p>

<h3>rm</h3>

<p>使用方法：<code>hadoop fs -rm URI [URI …]</code></p>

<p>删除指定的文件。只删除非空目录和文件。请参考rmr命令了解递归删除。</p>

<p>示例：</p>

<ul>
<li><code>hadoop fs -rm hdfs://host:port/file /user/hadoop/emptydir</code></li>
</ul>


<p>返回值：
成功返回0，失败返回-1。</p>

<h3>rmr</h3>

<p>使用方法：<code>hadoop fs -rmr URI [URI …]</code></p>

<p>delete的递归版本。</p>

<p>示例：</p>

<ul>
<li><code>hadoop fs -rmr /user/hadoop/dir</code></li>
<li><code>hadoop fs -rmr hdfs://host:port/user/hadoop/dir</code></li>
</ul>


<p>返回值：</p>

<p>成功返回0，失败返回-1。</p>

<h3>setrep</h3>

<p>使用方法：<code>hadoop fs -setrep [-R] &lt;path&gt;</code></p>

<p>改变一个文件的副本系数。-R选项用于递归改变目录下所有文件的副本系数。</p>

<p>示例：</p>

<ul>
<li><code>hadoop fs -setrep -w 3 -R /user/hadoop/dir1</code></li>
</ul>


<p>返回值：</p>

<p>成功返回0，失败返回-1。</p>

<h3>stat</h3>

<p>使用方法：<code>hadoop fs -stat URI [URI …]</code></p>

<p>返回指定路径的统计信息。</p>

<p>示例：</p>

<pre><code>* hadoop fs -stat path
</code></pre>

<p>返回值：</p>

<p>成功返回0，失败返回-1。</p>

<h3>tail</h3>

<p>使用方法：<code>hadoop fs -tail [-f] URI</code></p>

<p>将文件尾部1K字节的内容输出到stdout。支持-f选项，行为和Unix中一致。</p>

<p>示例：</p>

<ul>
<li><code>hadoop fs -tail pathname</code></li>
</ul>


<p>返回值：</p>

<p>成功返回0，失败返回-1。</p>

<h3>test</h3>

<p>使用方法：<code>hadoop fs -test -[ezd] URI</code></p>

<p>选项：</p>

<p>-e 检查文件是否存在。如果存在则返回0。</p>

<p>-z 检查文件是否是0字节。如果是则返回0。</p>

<p>-d 如果路径是个目录，则返回1，否则返回0。</p>

<p>示例：</p>

<ul>
<li><code>hadoop fs -test -e filename</code></li>
</ul>


<h3>text</h3>

<p>使用方法：<code>hadoop fs -text &lt;src&gt;</code></p>

<p>将源文件输出为文本格式。允许的格式是zip和TextRecordInputStream。</p>

<h3>touchz</h3>

<p>使用方法：<code>hadoop fs -touchz URI [URI …]</code></p>

<p>创建一个0字节的空文件。</p>

<p>示例：</p>

<ul>
<li><code>hadoop -touchz pathname</code></li>
</ul>


<p>返回值：</p>

<p>成功返回0，失败返回-1。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[php中global和$GLOBALS[]的用法、解释、区别]]></title>
    <link href="http://yblu.github.io/blog/2015/03/20/php-global.vs$GLOBALS%5B%5D/"/>
    <updated>2015-03-20T00:00:00+08:00</updated>
    <id>http://yblu.github.io/blog/2015/03/20/php-global.vs$GLOBALS[]</id>
    <content type="html"><![CDATA[<p>php语法中，很多人都认为global和$GLOBALS[]只是写法上面的差别，其实不然
根据官方的解释是
1.$GLOBALS[‘var’]是外部的全局变量本身
2.global $var是外部$var的同名引用或者指针。</p>

<p>举例说明一下：</p>

<pre><code>&lt;?php
$var1 = 1;
$var2 = 2;
function test(){
$GLOBALS[‘var2′] = &amp;$GLOBALS[‘var1′];
}
test();
echo $var2;
?&gt;
</code></pre>

<p>正常打印结果为1</p>

<pre><code>&lt;?php
$var1 = 1;
$var2 = 2;
function test(){
global $var1,$var2;
$var2 = &amp;$var1;
}
test();
echo $var2;
?&gt;
</code></pre>

<p>意外打印结果为2</p>

<p>为什么会打印结果为2呢？其实就是因为$var1的引用指向了$var2的引用地址。导致实质的值没有改变。
我们再来看一个例子吧。</p>

<pre><code>&lt;?php
$var1 = 1;
function test(){
unset($GLOBALS[‘var1′]);
}
test();
echo $var1;
?&gt;
</code></pre>

<p>因为$var1被删除了，所以什么东西都没有打印</p>

<pre><code>&lt;?php
$var1 = 1;
function test(){
global $var1;
unset($var1);
}
test();
echo $var1;
?&gt;
</code></pre>

<p>意外的打印了1。证明删除的只是别名|引用，起本身的值没有受到任何的改变
明白了吧？
也就是说global $var其实就是$var = &amp;$GLOBALS[‘var’]。调用外部变量的一个别名而已</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[大数据工程人员知识图谱]]></title>
    <link href="http://yblu.github.io/blog/2015/03/20/BigData-SkillMap/"/>
    <updated>2015-03-20T00:00:00+08:00</updated>
    <id>http://yblu.github.io/blog/2015/03/20/BigData-SkillMap</id>
    <content type="html"><![CDATA[<p>大数据相关工程人员需要掌握的技术相关知识点。主要涉及到数据库、数据仓库、编程、分布式系统、Hadoop生态系统相关、数据挖掘和机器学习相关的基础知识点</p>

<table>
    <tr>
        <td valign="top" width="62"><span style="color: #000000;">Topic</span></td>
        <td colspan="2" valign="top" width="113"><span style="color: #000000;">Content</span></td>
        <td valign="top" width="149"><span style="color: #000000;">Key points</span></td>
        <td valign="top" width="80"><span style="color: #000000;">Reference</span></td>
        </tr>
    <tr>
        <td rowspan="4" valign="top" width="62"><span style="color: #000000;">DB/OLTP &amp; DW/OLAP</span></td>
        <td colspan="2" valign="top" width="113"><span style="color: #000000;">Database/OLTP basic</span></td>
        <td valign="top" width="149"><span style="color: #000000;">The relational model, SQL, index/secondary index, inner join/left join/right join/full join, transaction/ACID</span></td>
        <td rowspan="4" valign="top" width="80"><span style="color: #000000;">Ramakrishnan, Raghu, and Johannes Gehrke. Database Management Systems.</span></td>
    </tr>
    <tr>
        <td colspan="2" valign="top" width="113"><span style="color: #000000;">Database internal &amp; implementation</span></td>
        <td valign="top" width="149"><span style="color: #000000;">Architecture, memory management, storage/B+ tree, query parse /optimization/execution, hash join/sort-merge join</span></td>
        </tr>
        <tr>
        <td colspan="2" valign="top" width="113"><span style="color: #000000;">Distributed and parallel database</span></td>
        <td valign="top" width="149"><span style="color: #000000;">Sharding, database proxy</span></td>
    </tr>
    <tr>
        <td colspan="2" valign="top" width="113"><span style="color: #000000;">Data warehouse/OLAP</span></td>
        <td valign="top" width="149"><span style="color: #000000;">Materialized views, ETL, column-oriented storage, reporting, BI tools</span></td>
    </tr>
    <tr>
        <td rowspan="5" valign="top" width="62"><span style="color: #000000;">Basic programming</span></td>
        <td colspan="2" valign="top" width="113"><span style="color: #000000;">Programming language</span></td>
        <td valign="top" width="149"><span style="color: #000000;">Java, Python (Pandas/NumPy/SciPy/scikit-learn), SQL, Functional programming, R/SAS/SPSS</span></td>
        <td rowspan="5" valign="top" width="80"><span style="color: #000000;">Wes McKinney. Python for Data Analysis: Agile Tools for Real World Data.</span>&nbsp;</td>
    </tr>
    <tr>
        <td colspan="2" valign="top" width="113"><span style="color: #000000;">OS</span></td>
        <td valign="top" width="149"><span style="color: #000000;">Linux</span></td>
    </tr>
    <tr>
        <td colspan="2" valign="top" width="113"><span style="color: #000000;">DB &amp; DW system</span></td>
        <td valign="top" width="149"><span style="color: #000000;">MySQL/ Hive/Impala</span></td>
    </tr>
    <tr>
        <td colspan="2" valign="top" width="113"><span style="color: #000000;">Text format and process</span></td>
        <td valign="top" width="149"><span style="color: #000000;">JSON/XML, regex</span></td>
    </tr>
    <tr>
        <td colspan="2" valign="top" width="113"><span style="color: #000000;">Tool</span></td>
        <td valign="top" width="149"><span style="color: #000000;">Git/SVN, Maven</span></td>
    </tr>
    <tr>
        <td rowspan="10" valign="top" width="62"><span style="color: #000000;">Distributed system &amp; Hadoop ecosystem &amp; NoSQL</span></td>
        <td colspan="2" valign="top" width="113"><span style="color: #000000;">Distributed system principal theory</span></td>
        <td valign="top" width="149"><span style="color: #000000;">CAP theorem, RPC (Protocol Buffer/Thrift/Avro), Zookeeper, Metadata management (HCatalog)</span></td>
        <td valign="top" width="80"></td>
    </tr>
    <tr>
        <td colspan="2" valign="top" width="113"><span style="color: #000000;">Distributed storage &amp; computing framework &amp; resource management</span></td>
        <td valign="top" width="149"><span style="color: #000000;">Hadoop/HDFS/MapReduce/YARN</span></td>
        <td valign="top" width="80"><span style="color: #000000;">Tom White. Hadoop : The Definitive Guide.</span><p></p>
        <p><span style="color: #000000;">Donald Miner, Adam Shook. MapReduce Design Patterns : Building Effective Algorithm and Analytics for Hadoop and Other Systems.</span></p></td>
    </tr>
    <tr>
    <td rowspan="2" valign="top" width="50"><span style="color: #000000;">SQL on Hadoop</span></td>
    <td valign="top" width="64"><span style="color: #000000;">Data (log) acquisition/integration/fusion, normalization, feature extraction</span></td>
    <td valign="top" width="149"><span style="color: #000000;">Sqoop, Flume/Scribe/Chukwa,</span><span style="color: #000000;">SerDe</span></td>
    <td rowspan="2" valign="top" width="80"><span style="color: #000000;">Edward Capriolo, Dean Wampler, Jason Rutherglen. Programming Hive.</span></td>
    </tr>
    <tr>
    <td valign="top" width="64"><span style="color: #000000;">Query &amp; In-database analytics</span></td>
    <td valign="top" width="149"><span style="color: #000000;">Hive, Impala, UDF/UDAF</span></td>
    </tr>
    <tr>
    <td colspan="2" valign="top" width="113"><span style="color: #000000;">Large scale data mining &amp; machine learning framework</span></td>
    <td valign="top" width="149"><span style="color: #000000;">Spark/MLbase, MR/Mahout</span></td>
    <td valign="top" width="80"></td>
    </tr>
    <tr>
    <td colspan="2" valign="top" width="113"><span style="color: #000000;">Streaming process</span></td>
    <td valign="top" width="149"><span style="color: #000000;">Storm</span></td>
    <td valign="top" width="80"></td>
    </tr>
    <tr>
    <td rowspan="4" colspan="2" valign="top" width="113"><span style="color: #000000;">NoSQL</span></td>
    <td valign="top" width="149"><span style="color: #000000;">HBase/Cassandra (column oriented database)</span></td>
    <td rowspan="4" valign="top" width="80"><span style="color: #000000;">Lars George. HBase: The Definitive Guide.</span></td>
    </tr>
    <tr>
    <td valign="top" width="149"><span style="color: #000000;">Mongodb (Document database)</span></td>
    </tr>
    <tr>
    <td valign="top" width="149"><span style="color: #000000;">Neo4j (graph database)</span></td>
    </tr>
    <tr>
    <td valign="top" width="149"><span style="color: #000000;">Redis (cache)</span></td>
    </tr>
    <tr>
    <td rowspan="10" valign="top" width="62"><span style="color: #000000;">Data mining &amp; Machine learning</span></td>
    <td colspan="2" valign="top" width="113"><span style="color: #000000;">DM &amp; ML basic</span></td>
    <td valign="top" width="149"><span style="color: #000000;">Numerical/Categorical variable, training/test data, over fitting, bias/variance, precision/recall, tagging</span></td>
    <td valign="top" width="80"></td>
    </tr>
    <tr>
    <td colspan="2" valign="top" width="113"><span style="color: #000000;">Statistic</span></td>
    <td valign="top" width="149"><span style="color: #000000;">Data exploration (mean, median/range/standard deviation/variance/histogram), Continues distributions (Normal/ Poisson/Gaussian), covariance, correlation coefficient, distance and similarity computing, Bayes theorem, Monte Carlo Method, Hypothesis testing</span></td>
    <td valign="top" width="80"></td>
    </tr>
    <tr>
    <td colspan="2" valign="top" width="113"><span style="color: #000000;">Supervised learning</span></td>
    <td valign="top" width="149"><span style="color: #000000;">Classifier, boosting, prediction, regression analysis</span></td>
    <td rowspan="7" valign="top" width="80">
    <p align="left"><span style="color: #000000;">Han, Jiawei,Micheline Kamber, and Jian Pei.&nbsp;Data mining: concepts and techniques.</span></p>
    <p>&nbsp;</p></td>
    </tr>
    <tr>
    <td colspan="2" valign="top" width="113"><span style="color: #000000;">Unsupervised learning</span></td>
    <td valign="top" width="149"><span style="color: #000000;">Cluster, deep learning</span></td>
    </tr>
    <tr>
    <td colspan="2" valign="top" width="113"><span style="color: #000000;">Collaborative filtering</span></td>
    <td valign="top" width="149">
    <p align="left"><span style="color: #000000;">Item based CF, user based CF</span></p>
    <p>&nbsp;</p></td>
    </tr>
    <tr>
    <td rowspan="4" valign="top" width="50"><span style="color: #000000;">Algorithm</span></td>
    <td valign="top" width="64"><span style="color: #000000;">Classifier</span></td>
    <td valign="top" width="149"><span style="color: #000000;">Decision trees, KNN (K-Nearest neighbor), SVM (support vector machines), SVD (Singular Value Decomposition), naïve Bayes classifiers, neural networks,</span></td>
    </tr>
    <tr>
    <td valign="top" width="64"><span style="color: #000000;">Regression</span></td>
    <td valign="top" width="149"><span style="color: #000000;">Linear regression, logistic regression, ranking, perception</span></td>
    </tr>
    <tr>
    <td valign="top" width="64"><span style="color: #000000;">Cluster</span></td>
    <td valign="top" width="149"><span style="color: #000000;">Hierarchical cluster, K-means cluster, Spectral Cluster</span></td>
    </tr>
    <tr>
    <td valign="top" width="64"><span style="color: #000000;">Dimensionality reduction</span></td>
    <td valign="top" width="149"><span style="color: #000000;">PCA (Principal Component Analysis), LDA (Linear discriminant Analysis), MDS (Multidimensional scaling)</span></td>
    </tr>
    <tr>
    <td colspan="2" valign="top" width="113"><span style="color: #000000;">Text mining &amp; Information retrieval</span></td>
    <td valign="top" width="149"><span style="color: #000000;">Corpus, term document matrix, term frequency &amp; weight, association rules, market based analysis, vocabulary mapping, sentiment analysis, tagging, PageRank, VSM (Vector Space Model), inverted index</span></td>
    <td valign="top" width="80"><span style="color: #000000;">Jimmy Lin and Chris Dyer. Data-Intensive Text Processing with MapReduce.</span></td>
    </tr>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[assertThat的用法]]></title>
    <link href="http://yblu.github.io/blog/2015/03/13/Java-assertThat/"/>
    <updated>2015-03-13T00:00:00+08:00</updated>
    <id>http://yblu.github.io/blog/2015/03/13/Java-assertThat</id>
    <content type="html"><![CDATA[<h3>一般匹配符</h3>

<ol>
<li><p><code>assertThat( testedNumber, allOf( greaterThan(8), lessThan(16) ) );</code></p>

<p> 注释： allOf匹配符表明如果接下来的所有条件必须都成立测试才通过，相当于“与”（&amp;&amp;）</p></li>
<li><p><code>assertThat( testedNumber, anyOf( greaterThan(16), lessThan(8) ) );</code></p>

<p> 注释：anyOf匹配符表明如果接下来的所有条件只要有一个成立则测试通过，相当于“或”（||）</p></li>
<li><p><code>assertThat( testedNumber, anything() );</code></p>

<p> 注释：anything匹配符表明无论什么条件，永远为true</p></li>
<li><p><code>assertThat( testedString, is( "developerWorks" ) );</code></p>

<p> 注释： is匹配符表明如果前面待测的object等于后面给出的object，则测试通过</p></li>
<li><p><code>assertThat( testedString, not( "developerWorks" ) );</code></p>

<p> 注释：not匹配符和is匹配符正好相反，表明如果前面待测的object不等于后面给出的object，则测试通过</p></li>
</ol>


<hr />

<h3>字符串相关匹配符</h3>

<ol>
<li><p><code>assertThat( testedString, containsString( "developerWorks" ) );</code></p>

<p>注释：containsString匹配符表明如果测试的字符串testedString包含子字符串"developerWorks"则测试通过</p></li>
<li><p><code>assertThat( testedString, endsWith( "developerWorks" ) )</code>;</p>

<p> 注释：endsWith匹配符表明如果测试的字符串testedString以子字符串"developerWorks"结尾则测试通过</p></li>
<li><p><code>assertThat( testedString, startsWith( "developerWorks" ) );</code></p>

<p> 注释：startsWith匹配符表明如果测试的字符串testedString以子字符串"developerWorks"开始则测试通过</p></li>
<li><p><code>assertThat( testedValue, equalTo( expectedValue ) );</code></p>

<p> 注释： equalTo匹配符表明如果测试的testedValue等于expectedValue则测试通过，equalTo可以测试数值之间，字符串之间和对象之间是否相等，相当于Object的equals方法</p></li>
<li><p><code>assertThat( testedString, equalToIgnoringCase( "developerWorks" ) );</code></p>

<p> 注释：equalToIgnoringCase匹配符表明如果测试的字符串testedString在忽略大小写的情况下等于"developerWorks"则测试通过</p></li>
<li><p><code>assertThat( testedString, equalToIgnoringWhiteSpace( "developerWorks" ) );</code></p>

<p> 注释：equalToIgnoringWhiteSpace匹配符表明如果测试的字符串testedString在忽略头尾的任意个空格的情况下等于"developerWorks"则测试通过，注意：字符串中的空格不能被忽略</p></li>
</ol>


<hr />

<h3>数值相关匹配符</h3>

<ol>
<li><p><code>assertThat( testedDouble, closeTo( 20.0, 0.5 ) );</code></p>

<p> 注释：closeTo匹配符表明如果所测试的浮点型数testedDouble在20.0±0.5范围之内则测试通过</p></li>
<li><p><code>assertThat( testedNumber, greaterThan(16.0) );</code></p>

<p> 注释：greaterThan匹配符表明如果所测试的数值testedNumber大于16.0则测试通过</p></li>
<li><p><code>assertThat( testedNumber, lessThan (16.0) );</code></p>

<p> 注释：lessThan匹配符表明如果所测试的数值testedNumber小于16.0则测试通过</p></li>
<li><p><code>assertThat( testedNumber, greaterThanOrEqualTo (16.0) );</code></p>

<p> 注释： greaterThanOrEqualTo匹配符表明如果所测试的数值testedNumber大于等于16.0则测试通过</p></li>
<li><p><code>assertThat( testedNumber, lessThanOrEqualTo (16.0) );</code></p>

<p> 注释：lessThanOrEqualTo匹配符表明如果所测试的数值testedNumber小于等于16.0则测试通过</p></li>
</ol>


<hr />

<h3>collection相关匹配符</h3>

<ol>
<li><p><code>assertThat( mapObject, hasEntry( "key", "value" ) );</code></p>

<p> 注释：hasEntry匹配符表明如果测试的Map对象mapObject含有一个键值为"key"对应元素值为"value"的Entry项则测试通过</p></li>
<li><p><code>assertThat( iterableObject, hasItem ( "element" ) );</code></p>

<p> 注释：hasItem匹配符表明如果测试的迭代对象iterableObject含有元素“element”项则测试通过</p></li>
<li><p><code>assertThat( mapObject, hasKey ( "key" ) );</code></p>

<p> 注释： hasKey匹配符表明如果测试的Map对象mapObject含有键值“key”则测试通过</p></li>
<li><p><code>assertThat( mapObject, hasValue ( "key" ) );</code></p>

<p> 注释：hasValue匹配符表明如果测试的Map对象mapObject含有元素值“value”则测试通过</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java 中 HashMap 的初始化]]></title>
    <link href="http://yblu.github.io/blog/2015/03/07/Java-HashMapInitiation/"/>
    <updated>2015-03-07T00:00:00+08:00</updated>
    <id>http://yblu.github.io/blog/2015/03/07/Java-HashMapInitiation</id>
    <content type="html"><![CDATA[<h3>1、普通写法</h3>

<pre><code>HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();
map.put("Name", "June");  
map.put("QQ", "4889983");
</code></pre>

<h3>2、文艺写法</h3>

<pre><code>HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;() {
    {
    put("Name", "June");  
    put("QQ", "4889983");  
    }
};
</code></pre>

<p>第一层括弧实际是定义了一个匿名内部类 (Anonymous Inner Class)，第二层括弧实际上是一个实例初始化块 (instance initializer block)，这个块在内部匿名类构造时被执行。这个块之所以被叫做“实例初始化块”是因为它们被定义在了一个类的实例范围内。</p>

<p>类似都可以在ArrayList、set上推广：</p>

<pre><code>List&lt;String&gt; names = new ArrayList&lt;String&gt;() {
    {
        for (int i = 0; i &lt; 10; i++) {
            add("A" + i);
        }
    }
};
</code></pre>

<h3>3、文艺写法存在的问题</h3>

<p>如果这个对象要串行化，可能会导致串行化失败。</p>

<ol>
<li><p>此种方式是匿名内部类的声明方式，所以引用中持有着外部类的引用。所以当时串行化这个集合时外           部类也会被不知不觉的串行化，当外部类没有实现serialize接口时，就会报错。</p></li>
<li><p>上例中，其实是声明了一个继承自HashMap的子类。然而有些串行化方法，例如要通过Gson串行化为         json，或者要串行化为xml时，类库中提供的方式，是无法串行化Hashset或者HashMap的子类的，从而导致串行化失败。解决办法：重新初始化为一个HashMap对象：</p>

<p> <code>new HashMap(map);</code></p>

<p> 这样就可以正常初始化了。</p></li>
<li>效率比普通写法低。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vim按键说明]]></title>
    <link href="http://yblu.github.io/blog/2015/02/27/Linux-Vim%20key%20description/"/>
    <updated>2015-02-27T00:00:00+08:00</updated>
    <id>http://yblu.github.io/blog/2015/02/27/Linux-Vim key description</id>
    <content type="html"><![CDATA[<ul class="list1"><li>第一部份：一般模式可用的按钮说明，光标移动、复制贴上、搜寻取代等</li></ul>


<div class="fontwidth">
<table bgcolor="lightyellow" border="1" cellpadding="3" cellspacing="0" width="95%">
<tbody><tr bgcolor="#182448"><td colspan="2" style="color: rgb(0, 0, 136); font-size: 1.1em; text-align: center;"><font color="#FFFFFF">移动光标的方法</font></td></tr>
    <tr><td style="text-align: center;" width="180">h 或 向左箭头键(←)</td>
        <td>光标向左移动一个字符</td></tr>
    <tr><td style="text-align: center;">j 或 向下箭头键(↓)</td>
        <td>光标向下移动一个字符</td></tr>
    <tr><td style="text-align: center;">k 或 向上箭头键(↑)</td>
        <td>光标向上移动一个字符</td></tr>
    <tr><td style="text-align: center;">l 或 向右箭头键(→)</td>
        <td>光标向右移动一个字符</td></tr>
    <tr><td colspan="2">
        如果你将右手放在键盘上的话，你会发现 hjkl 是排列在一起的，因此可以使用这四个按钮来移动光标。
        如果想要进行多次移动的话，例如向下移动 30 行，可以使用 "30j" 或 "30↓" 的组合按键，
        亦即加上想要进行的次数(数字)后，按下动作即可！</td></tr>
    <tr><td style="text-align: center;">[Ctrl] + [f]</td>
        <td>屏幕『向下』移动一页，相当于 [Page Down]按键
        (<span class="text_import2">常用</span>)</td></tr>
    <tr><td style="text-align: center;">[Ctrl] + [b]</td>
        <td>屏幕『向上』移动一页，相当于 [Page Up] 按键
        (<span class="text_import2">常用</span>)</td></tr>
    <tr><td style="text-align: center;">[Ctrl] + [d]</td>
        <td>屏幕『向下』移动半页</td></tr>
    <tr><td style="text-align: center;">[Ctrl] + [u]</td>
        <td>屏幕『向上』移动半页</td></tr>
    <tr><td style="text-align: center;">+</td>
        <td>光标移动到非空格符的下一列</td></tr>
    <tr><td style="text-align: center;">-</td>
        <td>光标移动到非空格符的上一列</td></tr>
    <tr><td style="text-align: center;">n&lt;space&gt;</td>
        <td>那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n
        个字符。例如 20&lt;space&gt; 则光标会向后面移动 20 个字符距离。</td></tr>
    <tr><td style="text-align: center;">0 或功能键[Home]</td>
        <td>这是数字『 0 』：移动到这一行的最前面字符处
        (<span class="text_import2">常用</span>)</td></tr>
    <tr><td style="text-align: center;">$ 或功能键[End]</td>
        <td>移动到这一行的最后面字符处(<span class="text_import2">常用</span>)</td></tr>
    <tr><td style="text-align: center;">H</td>
        <td>光标移动到这个屏幕的最上方那一行的第一个字符</td></tr>
    <tr><td style="text-align: center;">M</td>
        <td>光标移动到这个屏幕的中央那一行的第一个字符</td></tr>
    <tr><td style="text-align: center;">L</td>
        <td>光标移动到这个屏幕的最下方那一行的第一个字符</td></tr>
    <tr><td style="text-align: center;">G</td>
        <td>移动到这个档案的最后一行(<span class="text_import2">常用</span>)</td></tr>
    <tr><td style="text-align: center;">nG</td>
        <td>n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 
        行(可配合 :set nu)</td></tr>
    <tr><td style="text-align: center;">gg</td>
        <td>移动到这个档案的第一行，相当于 1G 啊！
        (<span class="text_import2">常用</span>)</td></tr>
    <tr><td style="text-align: center;">n&lt;Enter&gt;</td>
        <td>n 为数字。光标向下移动 n 行(<span class="text_import2">常用</span>)</td></tr>
<tr bgcolor="#182448"><td colspan="2" style="color: rgb(0, 0, 136); font-size: 1.1em; text-align: center;"><font color="#FFFFFF">搜寻与取代</font></td></tr>
    <tr><td style="text-align: center;">/word</td>
        <td>向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 
        这个字符串，就输入 /vbird 即可！
        (<span class="text_import2">常用</span>)</td></tr>
    <tr><td style="text-align: center;">?word</td>
        <td>向光标之上寻找一个字符串名称为 word 的字符串。</td></tr>
    <tr><td style="text-align: center;">n</td>
        <td>这个 n 是英文按键。代表『<u>重复前一个搜寻的动作</u>』。举例来说，
        如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 
        的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</td></tr>
    <tr><td style="text-align: center;">N</td>
        <td>这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。
        例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。</td></tr>
    <tr><td colspan="2">
        使用 /word 配合 n 及 N 是非常有帮助的！可以让你重复的找到一些你搜寻的关键词！
    </td></tr>
    <tr><td style="text-align: center;">:n1,n2s/word1/word2/g</td>
        <td>n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为
        word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则：<br>
        『:100,200s/vbird/VBIRD/g』。(<span class="text_import2">常用</span>)</td></tr>
    <tr><td style="text-align: center;">:1,$s/word1/word2/g</td>
        <td>从第一行到最后一行寻找 word1 字符串，并将该字符串取代为
        word2 ！(<span class="text_import2">常用</span>)</td></tr>
    <tr><td style="text-align: center;">:1,$s/word1/word2/gc</td>
        <td>从第一行到最后一行寻找 word1 字符串，并将该字符串取代为
        word2 ！且在取代前显示提示字符给用户确认 (confirm)
        是否需要取代！(<span class="text_import2">常用</span>)</td></tr>
<tr bgcolor="#182448"><td colspan="2" style="color: rgb(0, 0, 136); font-size: 1.1em; text-align: center;"><font color="#FFFFFF">删除、复制与贴上</font></td></tr>
    <tr><td style="text-align: center;">x, X</td>
        <td>在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)，
         X 为向前删除一个字符(相当于 [backspace] 亦即是退格键)
        (<span class="text_import2">常用</span>)</td></tr>
    <tr><td style="text-align: center;">nx</td>
        <td>n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符，
        『10x』。</td></tr>
    <tr><td style="text-align: center;">dd</td>
        <td>删除游标所在的那一整列(<span class="text_import2">常用</span>)</td></tr>
    <tr><td style="text-align: center;">ndd</td>
        <td>n 为数字。删除光标所在的向下 n 列，例如 20dd 则是删除 20 列
        (<span class="text_import2">常用</span>)</td></tr>
    <tr><td style="text-align: center;">d1G</td>
        <td>删除光标所在到第一行的所有数据</td></tr>
    <tr><td style="text-align: center;">dG</td>
        <td>删除光标所在到最后一行的所有数据</td></tr>
    <tr><td style="text-align: center;">d$</td>
        <td>删除游标所在处，到该行的最后一个字符</td></tr>
    <tr><td style="text-align: center;">d0</td>
        <td>那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td></tr>
    <tr><td style="text-align: center;">yy</td>
        <td>复制游标所在的那一行(<span class="text_import2">常用</span>)</td></tr>
    <tr><td style="text-align: center;">nyy</td>
        <td>n 为数字。复制光标所在的向下 n 列，例如 20yy 则是复制 20
        列(<span class="text_import2">常用</span>)</td></tr>
    <tr><td style="text-align: center;">y1G</td>
        <td>复制游标所在列到第一列的所有数据</td></tr>
    <tr><td style="text-align: center;">yG</td>
        <td>复制游标所在列到最后一列的所有数据</td></tr>
    <tr><td style="text-align: center;">y0</td>
        <td>复制光标所在的那个字符到该行行首的所有数据</td></tr>
    <tr><td style="text-align: center;">y$</td>
        <td>复制光标所在的那个字符到该行行尾的所有数据</td></tr>
    <tr><td style="text-align: center;">p, P</td>
        <td>p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！
        举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后，
        那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？
        那么原本的第 20 行会被推到变成 30 行。
        (<span class="text_import2">常用</span>)</td></tr>
    <tr><td style="text-align: center;">J</td>
        <td>将光标所在列与下一列的数据结合成同一列</td></tr>
    <tr><td style="text-align: center;">c</td>
        <td>重复删除多个数据，例如向下删除 10 行，[ 10cj ]</td></tr>
    <tr><td style="text-align: center;">u</td>
        <td>复原前一个动作。(<span class="text_import2">常用</span>)</td></tr>
    <tr><td style="text-align: center;">[Ctrl]+r</td>
        <td>重做上一个动作。(<span class="text_import2">常用</span>)</td></tr>
    <tr><td colspan="2">这个 u 与 [Ctrl]+r 是很常用的指令！一个是复原，另一个则是重做一次～
        利用这两个功能按键，你的编辑，嘿嘿！很快乐的啦！</td></tr>
    <tr><td style="text-align: center;">.</td>
        <td>不要怀疑！这就是小数点！意思是重复前一个动作的意思。
        如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！
        (<span class="text_import2">常用</span>)</td></tr>
    </tbody></table><br>

        <hr><ul class="list1"><li class="text_import1">第二部份：一般模式切换到编辑模式的可用的按钮说明</li></ul><br>

<table bgcolor="lightyellow" border="1" cellpadding="3" cellspacing="0" width="95%">
<tbody><tr bgcolor="#182448"><td colspan="2" style="color: rgb(0, 0, 136); font-size: 1.1em; text-align: center;"><font color="#FFFFFF">进入插入或取代的编辑模式</font></td></tr>
    <tr><td style="text-align: center;" width="120">i, I</td>
        <td>进入插入模式(Insert mode)：<br>
        i 为『从目前光标所在处插入』， I 为『在目前所在行的第一个非空格符处开始插入』。
        (<span class="text_import2">常用</span>)</td></tr>
    <tr><td style="text-align: center;">a, A</td>
        <td>进入插入模式(Insert mode)：<br>
        a 为『从目前光标所在的下一个字符处开始插入』， A
        为『从光标所在行的最后一个字符处开始插入』。(<span class="text_import2">常用</span>)</td></tr>
    <tr><td style="text-align: center;">o, O</td>
        <td>进入插入模式(Insert mode)：<br>
        这是英文字母 o 的大小写。o 为『在目前光标所在的下一行处插入新的一行』；
        O 为在目前光标所在处的上一行插入新的一行！(<span class="text_import2">常用</span>)</td></tr>
    <tr><td style="text-align: center;">r, R</td>
        <td>进入取代模式(Replace mode)：<br>
        r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下
        ESC 为止；(<span class="text_import2">常用</span>)</td></tr>
    <tr><td colspan="2">上面这些按键中，在 vi 画面的左下角处会出现『--INSERT--』或『--REPLACE--』的字样。
        由名称就知道该动作了吧！！特别注意的是，我们上面也提过了，你想要在档案里面输入字符时，
        一定要在左下角处看到 INSERT 或 REPLACE 才能输入喔！</td></tr>
    <tr><td style="text-align: center;">[Esc]</td>
        <td>退出编辑模式，回到一般模式中(<span class="text_import2">常用</span>)</td></tr>
    </tbody></table><br>

        <hr><ul class="list1"><li class="text_import1">第三部份：一般模式切换到指令列模式的可用的按钮说明</li></ul><br>

<table bgcolor="lightyellow" border="1" cellpadding="3" cellspacing="0" width="95%">
<tbody><tr bgcolor="#182448"><td colspan="2" style="color: rgb(0, 0, 136); font-size: 1.1em; text-align: center;"><font color="#FFFFFF">指令列的储存、离开等指令</font></td></tr>
    <tr><td style="text-align: center;" width="160">:w</td>
        <td>将编辑的数据写入硬盘档案中(<span class="text_import2">常用</span>)</td></tr>
    <tr><td style="text-align: center;">:w!</td>
        <td>若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入，
        还是跟你对该档案的档案权限有关啊！</td></tr>
    <tr><td style="text-align: center;">:q</td>
        <td>离开 vi (<span class="text_import2">常用</span>)</td></tr>
    <tr><td style="text-align: center;">:q!</td>
        <td>若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。</td></tr>
    <tr><td colspan="2">注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～</td></tr>
    <tr><td style="text-align: center;">:wq</td>
        <td>储存后离开，若为 :wq! 则为强制储存后离开
        (<span class="text_import2">常用</span>)</td></tr>
    <tr><td style="text-align: center;">ZZ</td>
        <td>这是大写的 Z 喔！若档案没有更动，则不储存离开，若档案已经被更动过，则储存后离开！</td></tr>
    <tr><td style="text-align: center;">:w [filename]</td>
        <td>将编辑的数据储存成另一个档案（类似另存新档）</td></tr>
    <tr><td style="text-align: center;">:r [filename]</td>
        <td>在编辑的数据中，读入另一个档案的数据。亦即将 『filename』
        这个档案内容加到游标所在行后面</td></tr>
    <tr><td style="text-align: center;">:n1,n2 w [filename]</td>
        <td>将 n1 到 n2 的内容储存成 filename 这个档案。</td></tr>
    <tr><td style="text-align: center;">:! command</td>
        <td>暂时离开 vi 到指令列模式下执行 command 的显示结果！例如<br>
        『:! ls /home』即可在 vi 当中察看 /home 底下以 ls 输出的档案信息！</td></tr>
<tr bgcolor="#182448"><td colspan="2" style="color: rgb(0, 0, 136); font-size: 1.1em; text-align: center;"><font color="#FFFFFF">vim 环境的变更</font></td></tr>
    <tr><td style="text-align: center;">:set nu</td>
        <td>显示行号，设定之后，会在每一行的前缀显示该行的行号</td></tr>
    <tr><td style="text-align: center;">:set nonu</td>
        <td>与 set nu 相反，为取消行号！</td></tr>
</tbody></table><br>
</div>


<div class="fontwidth">
<table bgcolor="lightyellow" border="1" cellpadding="3" cellspacing="0" width="95%">
<tbody><tr bgcolor="#182448"><td colspan="2" style="color: rgb(0, 0, 136); font-size: 1.1em; text-align: center;"><font color="#FFFFFF">区块选择的按键意义</font></td></tr>
    <tr><td style="text-align: center;">v</td><td>字符选择，会将光标经过的地方反白选择！</td></tr>
    <tr><td style="text-align: center;">V</td><td>行选择，会将光标经过的行反白选择！</td></tr>
    <tr><td style="text-align: center;">[Ctrl]+v</td><td>区块选择，可以用长方形的方式选择资料</td></tr>
    <tr><td style="text-align: center;">y</td><td>将反白的地方复制起来</td></tr>
    <tr><td style="text-align: center;">d</td><td>将反白的地方删除掉</td></tr>
</tbody></table><br>
</div>


<div class="fontwidth">
<table bgcolor="lightyellow" border="1" cellpadding="3" cellspacing="0" width="95%">
<tbody><tr bgcolor="#182448"><td colspan="2" style="color: rgb(0, 0, 136); font-size: 1.1em; text-align: center;"><font color="#FFFFFF">多档案编辑的按键</font></td></tr>
    <tr><td style="text-align: center;">:n</td><td>编辑下一个档案</td></tr>
    <tr><td style="text-align: center;">:N</td><td>编辑上一个档案</td></tr>
    <tr><td style="text-align: center;">:files</td><td>列出目前这个 vim 的开启的所有档案</td></tr>
</tbody></table><br>
</div>


<div class="fontwidth">
<table bgcolor="lightyellow" border="1" cellpadding="3" cellspacing="0" width="95%">
<tbody><tr bgcolor="#182448"><td colspan="2" style="color: rgb(0, 0, 136); font-size: 1.1em; text-align: center;"><font color="#FFFFFF">多窗口情况下的按键功能</font></td></tr>
    <tr><td style="text-align: center;" width="150">:sp [filename]</td><td>开启一个新窗口，如果有加 filename，
        表示在新窗口开启一个新档案，否则表示两个窗口为同一个档案内容(同步显示)。</td></tr>
    <tr><td style="text-align: center;">[ctrl]+w+ j<br>[ctrl]+w+↓</td><td>按键的按法是：先按下 [ctrl] 不放，
        再按下 w 后放开所有的按键，然后再按下 j (或向下箭头键)，则光标可移动到下方的窗口。</td></tr>
    <tr><td style="text-align: center;">[ctrl]+w+ k<br>[ctrl]+w+↑</td><td>同上，不过光标移动到上面的窗口。</td></tr>
    <tr><td style="text-align: center;">[ctrl]+w+ q</td><td>其实就是 :q 结束离开啦！
        举例来说，如果我想要结束下方的窗口，那么利用 [ctrl]+w+↓ 移动到下方窗口后，按下 :q 即可离开，
        也可以按下 [ctrl]+w+q 啊！</td></tr>
</tbody></table>
</div>


<div class="fontwidth">
<table bgcolor="lightyellow" border="1" cellpadding="3" cellspacing="0" width="95%">
<tbody><tr bgcolor="#182448"><td colspan="2" style="color: rgb(0, 0, 136); font-size: 1.1em; text-align: center;"><font color="#FFFFFF">vim 的环境设定参数</font></td></tr>
    <tr><td style="text-align: center;" width="170">:set nu<br>:set nonu</td><td>就是设定与取消行号啊！</td></tr>
    <tr><td style="text-align: center;">:set hlsearch<br>:set nohlsearch</td><td>hlsearch 就是 high light search(高亮度搜寻)。
        这个就是设定是否将搜寻的字符串反白的设定值。默认值是 hlsearch</td></tr>
    <tr><td style="text-align: center;">:set autoindent<br>:set noautoindent</td><td>是否自动缩排？autoindent 就是自动缩排。</td></tr>
    <tr><td style="text-align: center;">:set backup</td><td>是否自动储存备份档？一般是 nobackup 的，
        如果设定 backup 的话，那么当你更动任何一个档案时，则源文件会被另存成一个档名为 filename~ 的档案。
        举例来说，我们编辑 hosts ，设定 :set backup ，那么当更动 hosts 时，在同目录下，就会产生 hosts~ 
        文件名的档案，记录原始的 hosts 档案内容</td></tr>
    <tr><td style="text-align: center;">:set ruler</td><td>还记得我们提到的右下角的一些状态栏说明吗？
        这个 ruler 就是在显示或不显示该设定值的啦！</td></tr>
    <tr><td style="text-align: center;">:set showmode</td><td>这个则是，是否要显示 --INSERT-- 
        之类的字眼在左下角的状态栏。</td></tr>
    <tr><td style="text-align: center;">:set backspace=(012)</td><td>一般来说，
        如果我们按下 i 进入编辑模式后，可以利用退格键 (backspace) 来删除任意字符的。
        但是，某些 distribution 则不许如此。此时，我们就可以透过 backspace 来设定啰～
        当 backspace 为 2 时，就是可以删除任意值；0 或 1 时，仅可删除刚刚输入的字符，
        而无法删除原本就已经存在的文字了！</td></tr>
    <tr><td style="text-align: center;">:set all</td><td>显示目前所有的环境参数设定值。</td></tr>
    <tr><td style="text-align: center;">:set</td><td>显示与系统默认值不同的设定参数，
        一般来说就是你有自行变动过的设定参数啦！</td></tr>
    <tr><td style="text-align: center;">:syntax on<br>:syntax off</td><td>是否依据程序相关语法显示不同颜色？
        举例来说，在编辑一个纯文本档时，如果开头是以 # 开始，那么该行就会变成蓝色。
        如果你懂得写程序，那么这个 :syntax on 还会主动的帮你除错呢！但是，
        如果你仅是编写纯文本档案，要避免颜色对你的屏幕产生的干扰，则可以取消这个设定 。</td></tr>
    <tr><td style="text-align: center;">:set bg=dark<br>:set bg=light</td><td>
        可用以显示不同的颜色色调，预设是『 light 』。如果你常常发现批注的字体深蓝色实在很不容易看，
        那么这里可以设定为 dark 喔！试看看，会有不同的样式呢！</td></tr>
</tbody></table>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vim粘贴代码时缩进混乱]]></title>
    <link href="http://yblu.github.io/blog/2015/02/27/Linux-Vim/"/>
    <updated>2015-02-27T00:00:00+08:00</updated>
    <id>http://yblu.github.io/blog/2015/02/27/Linux-Vim</id>
    <content type="html"><![CDATA[<h2>1.问题</h2>

<p>在终端Vim中粘贴代码时，发现插入的代码会有多余的缩进，而且会逐行累加。
原因是终端把粘贴的文本存入键盘缓存（Keyboard Buffer）中，Vim则把这些内容作为用户的键盘输入来处理。
导致在遇到换行符的时候，如果Vim开启了自动缩进，就会默认的把上一行缩进插入到下一行的开头，最终使代码变乱。</p>

<p>另外SecureCRT会将你原来的文本原封不动的按照字符串的样式发送给服务器。所以当你的服务器上的vim设置为autoindent的话，在i模式下，那么它会将secureCRT传输而来的这些字符串再进行一下缩进。
若你拷贝的文本中已经有表示缩进的空格或者制表符的话，它们也会被当成字符串，而被缩进。</p>

<h2>2.解决方法</h2>

<h5>1. 取消自动缩进</h5>

<p>在命令模式下，使用“:set nosmartindent”和“:set noautoindent”取消自动缩进，然后再粘贴即可。完成后再开启自动缩进“:set smartindent”和“:set autoindent”，以上命令都可使用简写，比如“:set si”，可通过Vim的帮助“:help smartindent”查看相应说明。</p>

<h5>2. Paste模式</h5>

<p>Vim的编辑模式中，还有一个Paste模式，在该模式下，可将文本原本的粘贴到Vim中，以避免一些格式错误。通过“:set paste”和“:set nopaste”进入和退出该模式。更简便的方式是，在Vim中设置一个进入和退出Paste模式的快捷键，往“~/.vimrc”中添加一行配置“set pastetoggle=<F12>”，这样即可通过F12快速的在Paste模式中切换，当然快捷键在不冲突的前提下可以任意指定，具体如何指定，参考附带的教程链接。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Shell编程]]></title>
    <link href="http://yblu.github.io/blog/2015/01/27/Linux-shell/"/>
    <updated>2015-01-27T00:00:00+08:00</updated>
    <id>http://yblu.github.io/blog/2015/01/27/Linux-shell</id>
    <content type="html"><![CDATA[<h1>1.什么是shell</h1>

<p> shell script 是利用 shell 的功能所写的一个程序 (program)，这个程序是使用纯文字档，将一些 shell 的语法与命令(含外部命令)写在里面， 搭配正规表示法、管线命令与数据流重导向等功能，以达到我们所想要的处理目的。</p>

<p>shell脚本示例</p>

<pre><code>#!/bin/bash
# Program:
#   This program shows "Hello World!" in your screen.
# History:
# 2005/08/23    VBird   First release
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin
export PATH
echo -e "Hello World! \a \n"
exit 0
</code></pre>

<p>示例解释</p>

<ol>
<li>第一行#!/bin/bash在宣告这个script使用的shell名称</li>
</ol>


<h2>注意事项</h2>

<ol>
<li>命令的运行是从上而下、从左而右的分析与运行；</li>
<li>命令的下达就如同第五章内提到的： 命令、选项与参数间的多个空白都会被忽略掉；</li>
<li>空白行也将被忽略掉，并且 [tab] 按键所推开的空白同样视为空白键；</li>
<li>如果读取到一个 Enter 符号 (CR) ，就尝试开始运行该行 (或该串) 命令；</li>
<li>至於如果一行的内容太多，则可以使用『 [Enter] 』来延伸至下一行；</li>
<li><p>『 # 』可做为注解！任何加在 # 后面的数据将全部被视为注解文字而被忽略！</p></li>
<li></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hadoop中Partition解析]]></title>
    <link href="http://yblu.github.io/blog/2014/12/25/Hadoop-Partition/"/>
    <updated>2014-12-25T00:00:00+08:00</updated>
    <id>http://yblu.github.io/blog/2014/12/25/Hadoop-Partition</id>
    <content type="html"><![CDATA[<h3>1.解析Partition</h3>

<p>Map的结果，会通过partition分发到Reducer上，Reducer做完Reduce操作后，通过OutputFormat，进行输出，下面我们就来分析参与这个过程的类。
Mapper的结果，可能送到Combiner做合并，Combiner在系统中并没有自己的基类，而是用Reducer作为Combiner的基类，他们对外的功能是一样的，
只是使用的位置和使用时的上下文不太一样而已。Mapper最终处理的键值对&lt;key, value>，是需要送到Reducer去合并的，合并的时候，有相同key的
键/值对会送到同一个Reducer那。哪个key到哪个Reducer的分配过程，是由Partitioner规定的。它只有一个方法,</p>

<pre><code>getPartition(Text key, Text value, int numPartitions) 
</code></pre>

<p>输入时Map的结果对&lt;key, value>和Reducer的数目，输出则是分配的Reducer（整数编号）。就是指定Mapper输出的键值到哪一个reducer上去。系统缺省的Partition是HashPartitoner,它已key的Hash值对Reducer的数目取模，得到对应的Reducer。这样保证如果有相对的key值，肯定被分配到同一个reducer上。如果有N个reducer，编号就为0,1,2,3……（N-1)。</p>

<p>Reducer是所有用户定制Reducer类的基类，和Mapper类似，它也有setup，reducer，cleanup和run方法，其中setup和cleanup含义和和Mapper相同，reduce是真正合并到Mapper结果的地方，它的输入是key和这个key对用的所有value的一个迭代器，同时还包括Reducer的上下文。系统中定义了两个非常简单的Reducer，IntSumReducer和LongSumReducer，分别用于对整形/长整形的value求和。</p>

<p>Reduce的结果，通过Reducer.Context的方法collect输出到文件中，和输入类似，Hadoop引入了OutputFormat。OutputFormat依赖两个辅助接口：RecordWriter和OutputCommitter，来处理输出。RecordWriter提供了write方法，用于输出&lt;key, value>和close方法，用于关闭对应的输出。OutputCommitter提供了一系列方法，用户通过实现这些方法，可以定制OutputFormat生存期某些阶段需要的特殊操作。我们在TaskInputOutputContext中讨论过这些方法（明显，TaskInputOutputContext是OutputFormat和Reducer间的桥梁）。OutputFormat和RecordWriter分别对应着InputFormat和RecordReader，系统提供了空输出NullOutputFormat（什么结果都不输出，NullOutputFormat.RecordWriter只是示例，系统中没有定义），LazyOutputFormat（没在类图中出现，不分析），FilterOutputFormat（不分析）和基于文件FileOutputFormat的SequenceFileOutputFormat和TextOutputFormat输出。</p>

<p>基于文件的输出FileOutputFormat利用了一些配置项配合工作，包括:</p>

<ul>
<li>mapred.output.compress：是否压缩；</li>
<li>mapred.output.compression.codec：压缩方法；</li>
<li>mapred.output.dir：输出路径；</li>
<li>mapred.work.output.dir：输出工作路径。</li>
<li>FileOutputFormat还依赖于FileOutputCommitter，通过FileOutputCommitter提供一些和Job，Task相关的临时文件管理功能。如FileOutputCommitter的setupJob，会在输出路径下创建一个名为_temporary的临时目录，cleanupJob则会删除这个目录。</li>
<li>SequenceFileOutputFormat输出和TextOutputFormat输出分别对应输入的SequenceFileInputFormat和TextInputFormat。</li>
</ul>


<h3>2.代码实例</h3>

<pre><code>package org.apache.hadoop.examples;

import java.io.IOException;
import java.util.*;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.conf.*;
import org.apache.hadoop.io.*;
import org.apache.hadoop.mapred.*;
import org.apache.hadoop.util.*;

/**
 * 输入文本，以tab间隔
 * kaka    1       28
 * hua     0       26
 * chao    1
 * tao     1       22
 * mao     0       29      22
 * */

//Partitioner函数的使用

public class MyPartitioner {
    // Map函数
    public static class MyMap extends MapReduceBase implements
            Mapper&lt;LongWritable, Text, Text, Text&gt; {
        public void map(LongWritable key, Text value,
                OutputCollector&lt;Text, Text&gt; output, Reporter reporter)
                throws IOException {
            String[] arr_value = value.toString().split("\t");
            //测试输出
//          for(int i=0;i&lt;arr_value.length;i++)
//          {
//              System.out.print(arr_value[i]+"\t");
//          }
//          System.out.print(arr_value.length);
//          System.out.println();       
            Text word1 = new Text();
            Text word2 = new Text();
            if (arr_value.length &gt; 3) {
                word1.set("long");
                word2.set(value);
            } else if (arr_value.length &lt; 3) {
                word1.set("short");
                word2.set(value);
            } else {
                word1.set("right");
                word2.set(value);
            }
            output.collect(word1, word2);
        }
    }

public static class MyReduce extends MapReduceBase implements
        Reducer&lt;Text, Text, Text, Text&gt; {
    public void reduce(Text key, Iterator&lt;Text&gt; values,
            OutputCollector&lt;Text, Text&gt; output, Reporter reporter)
            throws IOException {
        int sum = 0;
        System.out.println(key);
        while (values.hasNext()) {
            output.collect(key, new Text(values.next().getBytes()));    
        }
    }
}

// 接口Partitioner继承JobConfigurable，所以这里有两个override方法
public static class MyPartitionerPar implements Partitioner&lt;Text, Text&gt; {
    /**
     * getPartition()方法的
     * 输入参数：键/值对&lt;key,value&gt;与reducer数量numPartitions
     * 输出参数：分配的Reducer编号，这里是result
     * */
    @Override
    public int getPartition(Text key, Text value, int numPartitions) {
        // TODO Auto-generated method stub
        int result = 0;
        System.out.println("numPartitions--" + numPartitions);
        if (key.toString().equals("long")) {
            result = 0 % numPartitions;
        } else if (key.toString().equals("short")) {
            result = 1 % numPartitions;
        } else if (key.toString().equals("right")) {
            result = 2 % numPartitions;
        }
        System.out.println("result--" + result);
        return result;
    }

    @Override
    public void configure(JobConf arg0) 
    {
        // TODO Auto-generated method stub
    }
}

//输入参数：/home/hadoop/input/PartitionerExample /home/hadoop/output/Partitioner
public static void main(String[] args) throws Exception {
    JobConf conf = new JobConf(MyPartitioner.class);
    conf.setJobName("MyPartitioner");

    //控制reducer数量，因为要分3个区，所以这里设定了3个reducer
    conf.setNumReduceTasks(3);

    conf.setMapOutputKeyClass(Text.class);
    conf.setMapOutputValueClass(Text.class);

    //设定分区类
    conf.setPartitionerClass(MyPartitionerPar.class);

    conf.setOutputKeyClass(Text.class);
    conf.setOutputValueClass(Text.class);

    //设定mapper和reducer类
    conf.setMapperClass(MyMap.class);
    conf.setReducerClass(MyReduce.class);

    conf.setInputFormat(TextInputFormat.class);
    conf.setOutputFormat(TextOutputFormat.class);

    FileInputFormat.setInputPaths(conf, new Path(args[0]));
    FileOutputFormat.setOutputPath(conf, new Path(args[1]));

    JobClient.runJob(conf);
}
</code></pre>

<p>}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[经典面试题atoi]]></title>
    <link href="http://yblu.github.io/blog/2014/12/17/atoi-implementation/"/>
    <updated>2014-12-17T00:00:00+08:00</updated>
    <id>http://yblu.github.io/blog/2014/12/17/atoi-implementation</id>
    <content type="html"><![CDATA[<h2>功能简介</h2>

<p>atoi是把字符串转换成长整型数的一种函数</p>

<h2>linux c库函数实现</h2>

<pre><code>/***
*long atol(char *nptr) - Convert string to long
*
*Purpose:
*       Converts ASCII string pointed to by nptr to binary.
*       Overflow is not detected.
*
*Entry:
*       nptr = ptr to string to convert
*
*Exit:
*       return long int value of the string
*
*Exceptions:
*       None - overflow is not detected.
*
*******************************************************************************/

long __cdecl atol(
        const char *nptr
        )
{
    int c;              /* current char */
    long total;         /* current total */
    int sign;           /* if '-', then negative, otherwise positive */

    /* skip whitespace */
    while ( isspace((int)(unsigned char)*nptr) )
        ++nptr;

    c = (int)(unsigned char)*nptr++;
    sign = c;           /* save sign indication */
    if (c == '-' || c == '+')
        c = (int)(unsigned char)*nptr++;    /* skip sign */

    total = 0;

    while (isdigit(c)) {
        total = 10 * total + (c - '0');     /* accumulate digit */
        c = (int)(unsigned char)*nptr++;    /* get next char */
    }

    if (sign == '-')
        return -total;
    else
        return total;   /* return result, negated if necessary */
}


/***
*int atoi(char *nptr) - Convert string to long
*
*Purpose:
*       Converts ASCII string pointed to by nptr to binary.
*       Overflow is not detected.  Because of this, we can just use
*       atol().
*
*Entry:
*       nptr = ptr to string to convert
*
*Exit:
*       return int value of the string
*
*Exceptions:
*       None - overflow is not detected.
*
*******************************************************************************/

int __cdecl atoi(
        const char *nptr
        )
{
        return (int)atol(nptr);
}
</code></pre>

<p>面试官至少会期待应聘都能够在不需要提示的情况下，考虑到输入的字符串中有非数字字符和正负号，要考虑到最大的正整数和最小的负整数以及溢出。同时面试试还期待应聘者能够考虑到当输入的字符串不能转换成整数时，应该如何做错误处理。</p>

<p>1、检查字符串是否为空</p>

<p>2、对非法输入，返回0，并设置全局变量</p>

<p>3、溢出</p>

<p>4、空字符串""</p>

<p>5、输入字符串只有"+&ldquo;或&rdquo;-&ldquo;号</p>

<pre><code>// StringToInt.cpp : Defines the entry point for the console application.
//

// 《剑指Offer——名企面试官精讲典型编程题》代码
// 著作权所有者：何海涛

#include "stdafx.h"
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

long long StrToIntCore(const char* str, bool minus);

enum Status {kValid = 0, kInvalid};
int g_nStatus = kValid;

int StrToInt(const char* str)
{
        g_nStatus = kInvalid;
        long long num = 0;

    if(str != NULL &amp;&amp; *str != '\0') 
    {
        bool minus = false;
        if(*str == '+')
            str ++;
        else if(*str == '-') 
        {
            str ++;
            minus = true;
        }

        if(*str != '\0') 
        {
            num = StrToIntCore(str, minus);
        }
    }

    return (int)num;
}

long long StrToIntCore(const char* digit, bool minus)
{
    long long num = 0;

    while(*digit != '\0') 
    {
        if(*digit &gt;= '0' &amp;&amp; *digit &lt;= '9') 
        {
            int flag = minus ? -1 : 1;
            num = num * 10 + flag * (*digit - '0');

            if((!minus &amp;&amp; num &gt; 0x7FFFFFFF) 
                || (minus &amp;&amp; num &lt; (signed int)0x80000000))
            {
                num = 0;
                break;
            }

            digit++;
        }
        else 
        {
            num = 0;
            break;
        }
    }

    if(*digit == '\0') 
    {
        g_nStatus = kValid;
    }

    return num;
}

// ====================测试代码====================
void Test(char* string)
{
    int result = StrToInt(string);
    if(result == 0 &amp;&amp; g_nStatus == kInvalid)
        printf("the input %s is invalid.\n", string);
    else
        printf("number for %s is: %d.\n", string, result);
}

int _tmain(int argc, _TCHAR* argv[])
{
    Test(NULL);

    Test("");

    Test("123");

    Test("+123");

    Test("-123");

    Test("1a33");

    Test("+0");

    Test("-0");

    //有效的最大正整数, 0x7FFFFFFF
    Test("+2147483647");    

    Test("-2147483647");

    Test("+2147483648");

    //有效的最小负整数, 0x80000000
    Test("-2147483648");    

    Test("+2147483649");

    Test("-2147483649");

    Test("+");

    Test("-");

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[面向对象的编程语言的特征]]></title>
    <link href="http://yblu.github.io/blog/2014/12/15/leanring-note/"/>
    <updated>2014-12-15T00:00:00+08:00</updated>
    <id>http://yblu.github.io/blog/2014/12/15/leanring-note</id>
    <content type="html"><![CDATA[<p>有以下有4个主要特征</p>

<h4>封装</h4>

<p>封装是保证软件部件具有优良的模块性的基础，封装的目标就是要实现软件部件的“高内聚、低耦合”，防止程序相互依赖性而带来的变动影响。在面向对象的编程语言中，对象是封装
的最基本单位，面向对象的封装比传统语言的封装更为清晰、更为有力。面向对象的封装就
是把描述一个对象的属性和行为的代码封装在一个“模块”中，也就是一个类中，属性用变量
定义，行为用方法进行定义，方法可以直接访问同一个对象中的属性。通常情况下，只要记
住让变量和访问这个变量的方法放在一起，将一个类中的成员变量全部定义成私有的，只
有这个类自己的方法才可以访问到这些成员变量，这就基本上实现对象的封装，就很容易
找出要分配到这个类上的方法了，就基本上算是会面向对象的编程了。把握一个原则：把
对同一事物进行操作的方法和相关的方法放在同一个类中，把方法和它操作的数据放在同
一个类中。</p>

<p>例如，人要在黑板上画圆，这一共涉及三个对象：人、黑板、圆，画圆的方法要分配给哪个
对象呢？由于画圆需要使用到圆心和半径，圆心和半径显然是圆的属性，如果将它们在类中
定义成了私有的成员变量，那么，画圆的方法必须分配给圆，它才能访问到圆心和半径这两
个属性，人以后只是调用圆的画圆方法、表示给圆发给消息而已，画圆这个方法不应该分配
在人这个对象上，这就是面向对象的封装性，即将对象封装成一个高度自治和相对封闭的
个体，对象状态（属性）由这个对象自己的行为（方法）来读取和改变。一个更便于理解
的例子就是，司机将火车刹住了，刹车的动作是分配给司机，还是分配给火车，显然，应该
分配给火车，因为司机自身是不可能有那么大的力气将一个火车给停下来的，只有火车自己
才能完成这一动作，火车需要调用内部的离合器和刹车片等多个器件协作才能完成刹车这个
动作，司机刹车的过程只是给火车发了一个消息，通知火车要执行刹车动作而已。</p>

<h4>抽象</h4>

<p>抽象就是找出一些事物的相似和共性之处，然后将这些事物归为一个类，这个类只考虑这些
事物的相似和共性之处，并且会忽略与当前主题和目标无关的那些方面，将注意力集中在与
当前目标有关的方面。例如，看到一只蚂蚁和大象，你能够想象出它们的相同之处，那就是
抽象。抽象包括行为抽象和状态抽象两个方面。例如，定义一个Person类，如下：</p>

<pre><code>classPerson{
    string name;
    int age;
</code></pre>

<p>人本来是很复杂的事物，有很多方面，但因为当前系统只需要了解人的姓名和年龄，所以上
面定义的类中只包含姓名和年龄这两个属性，这就是一种抽像，使用抽象可以避免考虑一些
与目标无关的细节。我对抽象的理解就是不要用显微镜去看一个事物的所有方面，这样涉及
的内容就太多了，而是要善于划分问题的边界，当前系统需要什么，就只考虑什么。</p>

<h4>继承</h4>

<p>在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在
的类所定义的内容作为自己的内容，并可以加入若干新的内容，或修改原来的方法使之更适
合特殊的需要，这就是继承。继承是子类自动共享父类数据和方法的机制，这是类之间的一
种关系，提高了软件的可重用性和可扩展性。</p>

<h4>多态</h4>

<p>多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编
程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，
该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。
因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到
各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以
改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。多态性
增强了软件的灵活性和扩展性。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[统计学习的一些概念]]></title>
    <link href="http://yblu.github.io/blog/2014/12/04/ML-basic-concept/"/>
    <updated>2014-12-04T00:00:00+08:00</updated>
    <id>http://yblu.github.io/blog/2014/12/04/ML-basic-concept</id>
    <content type="html"><![CDATA[<h1>统计学习的一些概念</h1>

<p>统计学习的输入变量和输出 变量可以有不同的类型。根据输入输出可划分为以下几类，及其相应常用的算法。</p>

<h5>回归问题</h5>

<ul>
<li>输入变量与输出变量均为连续变量的预测问题；</li>
<li>最小二乘法</li>
</ul>


<h5>分类问题</h5>

<ul>
<li>输入变量可以使离散的或连续的，但输出变量是有限个离散变量的预测问题；</li>
<li>K邻近法、感知机、朴素贝叶斯法、决策树、决策列表、逻辑斯谛回归模型、支持向量机、提升方法、贝叶斯网络、神经网络，Winnow等</li>
</ul>


<h5>标准问题</h5>

<ul>
<li>输入变量与输出变量均为离散变量的预测问题。</li>
<li>隐形马尔科夫模型、条件随机场</li>
</ul>


<p>输入定义在输入(特征）空间，输入=特征向量</p>

<p>训练数据由输入与输出成对组成训练集</p>

<p>统计学习方法三要素：<strong>方法=模型+策略+算法</strong></p>

<p>学习方法的泛化能力是指由该方法学习到的模型对位置数据的预测能力。可以用泛化误差来衡量。</p>
]]></content>
  </entry>
  
</feed>
